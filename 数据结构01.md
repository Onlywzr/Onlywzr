

### 集合框架

如果并不知道程序运行时会需要多少对象，或者需要 更复杂方式存储对象——可以使用Java集合框架

![image-20211208165416722](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211208165416722.png)

#### Collection 接口

存储一组不唯一（可以包含重复元素），无序的对象  

```
特点：
*           1、可以存放不同类型的数据，而数组只能存放固定类型的数据
*           2、当使用arraylist子类实现的时候，初始化的长度是10，当长度不够的时候会自动进行扩容操作
*       api方法：
*           增加数据的方法
*           add：要求必须传入的参数是Object对象，因此当写入基本数据类型的时候，包含了自动拆箱和自动装箱的过程
*           addAll:添加另一个集合的元素到此集合中
*
*           删除数据的方法
*           clear:只是清空集合中的元素，但是此集合对象并没有被回收
*           remove:删除指定元素
*           removeAll：删除集合元素
*
*           查询数据的方法
*           contains:判断集合中是否包含指定的元素值
*           containsAll:判断此集合中是否包含另一个集合
*           isEmpty:判断集合是否等于空
*           retainAll:若集合中拥有另一个集合的所有元素，返回true，否则返回false
*           size:返回当前集合的大小
*
*           //集合转数组的操作
*           toArray:将集合转换成数组
```

#### List 接口

存储一组不唯一，有序（插入顺序）的对象

ArrayList实现了长度可变的数组，在内存中分配连续的空间。 – 优点：遍历元素和随机访问元素的效率比较高 – 缺点：添加和删除需要大量移动元素效率低，按照内容查询效 率低

 LinkedList采用链表存储方式。 – 优点：插入、删除元素时效率比较高 – 缺点：遍历和随机访问元素效率低下

*      1、Vector也是List接口的一个子类实现
*      2、Vector跟ArrayList一样，底层都是使用数组进行实现的
*      3、面试经常问区别：
*          （1）ArrayList是线程不安全的，效率高，Vector是线程安全的，效率低
*          （2）ArrayList在进行扩容的时候，是扩容1.5倍，Vector扩容的时候扩容原来的2倍

#### Iterator迭代器

```java
* 在java代码中包含三种循环的方式
*   do...while
*   while
*   for
* 还有一种增强for循环的方式，可以简化循环的编写
//        for(Object i : list){
//            System.out.println(i);
//        }
*
*   所有的集合类都默认实现了Iterable的接口，实现此接口意味着具备了增强for循环的能力，也就是for-each
*      增强for循环本质上使用的也是迭代器iterator的功能
*      方法：
*               iterator()
*               foreach()
*   在iterator的方法中，要求返回一个Iterator的接口子类实例对象
*       此接口中包含了
*               hasNext()
*               next()
*
*   在使用iterator进行迭代的过程中如果删除其中的某个元素会报错，并发操作异常，因此
*       如果遍历的同时需要修改元素，建议使用listIterator（），
*   ListIterator迭代器提供了向前和向后两种遍历的方式
*       始终是通过cursor和lastret的指针来获取元素值及向下的遍历索引
*       当使用向前遍历的时候必须要保证指针在迭代器的结果，否则无法获取结果值
```

Iterator迭代器实现方法：本质就是cursor以及lastRet两个指针移动的过程，开始时cursor=0，lastRet=-1,每遍历完一个之后两个指针下移（值＋1），每次调用next函数移动指针，hasnext函数判断循环是否结束

```java
public class Itr implements Iterator<E> {
    int cursor;
    int lastRet = -1;
    int expectedModCount = modCount;
    Itr();
    public boolean hasNext(){return cursor!=size;} //当cursor值等于集合大小时返回false
    public E next(){
        int i = cursor;
        if(i>size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.element.Data;
        if (i>elemantData.length)
            throw new CencurrentModificationException();
        cursor = i+1; //每遍历一个把cursor指针+1
        return (E) elementData[lastRet = i];//返回第i个元素，同时令lastret指针值为i
    }
}
```

```java
//在遍历的过程中进行删除
//Iterator iterator = list.iterator(); //原迭代器
ListIterator iterator = list.listIterator();  //解决方法：新建一个这样的迭代器      
while(iterator.hasNext()){
            Object o = iterator.next();
            if(o.equals(1)){ //删除1位置的元素，会报错！！！！在数组中删除1位置的数后，1位置后面的数会按序往前移动1位，指针指向的值会发生变化，导致数据错乱，引发并发操作异常
                iterator.remove(); //使用iteator对象进行删除 ，此remove不同于list.remove，其在删除的同时对指针的值进行了改变
            }
            System.out.println(o);
}
while (iterator.hasPrevious()){
      System.out.println(iterator.previous()); //向前遍历，但是这时指针要在迭代器结尾，否则要没结果值
}
```

#### Set接口 

存储一组唯一（值不可以重复），无序的对象 

– （存入和取出的顺序不一定一致）

– 操作数据的方法不List类似，Set接口不存在get()方法

底层是用红黑树存储的

补充基础知识：

- BST树（二叉搜索树）通过二叉树将数据组织起来。

  特点：左右子树分别也是二叉搜索树

  左子树的所有节点key值都小于它的根节点的key值

  右子树的所有节点key值都大于它的根节点的key值

  BST树可以为一棵空树

- AVL树（平衡二叉搜索树）查询效率更高

  AVL树是一棵二叉搜索树

  AVL树的左右子节点也是AVL树

  每个节点的左右子节点的高度之差的绝对值最多为1，即平衡因子范围为[-1,1]

- 红黑树是一种自平衡二叉查找树，在插入和删除操作时能通过旋转操作保持二叉查找树的平衡，以便能获得高效的查找性能，它可以在O(NlogN)时间内做查找、插入、删除等操作，红黑树时2-3-4树的一种等同。对于AVL树来说，**红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，**整体性能优于AVL树。

  特点:

  节点是红色或黑色

  根结点是黑色；每个叶子节点是黑色。

  每个红节点的两个子节点都为黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）

  从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点

  所有红黑树节点下面都会有nullleaf，表示当前没有叶子元素

  **最长路径不超过最短路径的2倍**

  ​                                                                      AVL树这样旋转：

  <img src="C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211210172033776.png" alt="image-20211210172033776" style="zoom:33%;" />

  *  1、set中存放的是无序，唯一的数据
  *  2、set不可以通过下标获取对应位置的元素的值，因为无序的特点
  *  3、使用treeset底层的实现是treemap,利用红黑树来进行实现（红黑树是一种特殊的平衡树（AVL）：左子树和右子树高度相差不能超过1，查找时采用二分查找）
  *  4、设置元素的时候，如果是自定义对象，会查找对象中的equals和hashcode的方法，如果没有，比较的是地址
  ▪ HashSet是如何保证元素的唯一性的呢?
  ▪ 答:是通过元素的两个方法,hashCode和equals方法来完成
  ▪ 如果元素的HashCode值相同，才会判断equals是否为true。比较hashcode是为了确定当前元素值放到哪一个单元格里
  ▪ 如果元素的hashCode值不同，不会调用equals方法
  *  5、（重要！）树中的元素是要默认进行排序操作的，如果是基本数据类型，自动比较，如果是引用类型的话，需要自定义比较器
  *       比较器分类：
  *  内部比较器：定义在元素的类中(如person类中），通过实现comparable接口来进行实现
  *  外部比较器：定义在当前类中，通过实现comparator接口来实现，但是要将该比较器传递到集合中
  *       重要！注意：**外部比较器可以定义成一个工具类，此时所有需要比较的规则如果一致的话，可以复用，而**
  *               内部比较器只有在存储当前对象的时候才可以使用
  *               **如果两者同时存在，使用外部比较器**，
  *               当使用比较器的时候，不会调用equals方法

```java
public HashSet(){ //hashset源代码，hashset本质也是hashmap
    map = new HashMap<>();
}

//定义内部比较器（person类中）
public class Person implements Comparable{
    private String name;
    private int age;

    public Person(){

    }
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public int compareTo(Object o) {
        Person p  = (Person) o;
        if (p.name.length()>this.name.length()){
            return -1;
        }else if(p.name.length()<this.name.length()){
            return 1;
        }else{
            return 0;
        }
    }
}
//定义外部比较器
     public int compare(Person o1, Person o2) {
        if(o1.getAge()>o2.getAge()){
            return -1;
        }else if(o1.getAge() < o2.getAge()){
            return 1;
        }else{
            return 0;
        }
    }
//插入元素到treeset中并输出，因为类里有两个类型，所以要定义比较器告诉如何比较！
        TreeSet treeSet = new TreeSet();//调用内部比较器
        TreeSet treeSet = new TreeSet(new SetDemo());//调用外部比较器，需要写出当前类名（如SetDemo）将比较器传递到集合中
        treeSet.add(new Person("lisi",15));
        treeSet.add(new Person("wangwu",13));
        treeSet.add(new Person("maliu",12));
        treeSet.add(new Person("zhangsan",19));
        treeSet.add(new Person("zhangsan",12));
        System.out.println(treeSet);

```

![image-20211209205213072](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211209205213072.png)

哈希表：对每个元素按照一定规则计算出哈希值，然后把元素放到哈希值的位置上。常用：i mod 数据长度。当多个值要放在同一个位置时，在下面接链表。

```java
public boolean equals(Object o) {
    if (this == o) return true; //this指代boolean当前对象本身，o代表传进的参数。=比较的是对应的地址值，还要比较属性值！
    if (o == null || getClass() != o.getClass()) return false;//等于空或两个对象类型不一样
    Dog dog = (Dog) o; //强制转换
    return Objects.equals(name, dog.name) &&
            Objects.equals(color, dog.color);
}
```

#### 范型

```java
* 当做一些集合的统一操作的时候，需要保证集合的类型是统一的，此时需要泛型来进行限制
*      优点：
*          1、数据安全
*          2、获取数据时效率比较高
*      给集合中的元素设置相同的类型就是泛型的基本需求
*       使用：
*          在定义对象的时候，通过<>中设置合理的类型来进行实现
           List<String> list = new ArrayList<String>();//限制放置string类型数据
*  泛型的高阶应用：
*      1、泛型类
*          在定义类的时候在类名的后面添加<E,K,V,A,B>,起到占位的作用，类中的方法的返回值类型和属性的类型都可以使用，类型是用户动态传参传进来的。
public class FanXingClass<A> {
    private int id;
    private A a;
    public void setId(int id) {
        this.id = id;
    }
    public A getA() {
        return a;
    }
    public void setA(A a) {
        this.a = a;
    }
    public void show(){
        System.out.println("id : "+id+" ,A : "+a);
    }
    public A get(){
        return a; //返回类型
    }
    public void set(A a){
        System.out.println("执行set方法：" + a);
    }
}
*      2、泛型接口
*          在定义接口的时候，在接口的名称后添加<E,K,V,A,B>,
*          1、子类在进行实现的时候，可以不填写泛型的类型，此时在创建具体的子类对象的时候才决定使用什么类型
*          2、子类在实现泛型接口的时候，只在实现父类的接口的时候指定父类的泛型类型即可，此时，测试方法中的泛型类型必须要跟子类保持一致
*      3、泛型方法
*          在定义方法的时候，指定方法的返回值和参数是自定义的占位符，可以是类名中的T,也可以是自定义的Q，只不过在使用Q的时候需要使用<Q>定义在返回值的前面
*      4、泛型的上限（工作中不用）
*          如果父类确定了，所有的子类都可以直接使用
*      5、泛型的下限（工作中不用）
*          如果子类确定了，子类的所有父类都可以直接传递参数使用
```

#### Map

接口存储一组键值对象，提供key到value的映射（提供索引值）

▪ HashMap – Key无序 唯一（Set）– Value无序 不唯一(Collection)  采用哈希表结构

哈希表：对每个元素按照一定规则计算出哈希值，然后把元素放到哈希值的位置上。常用：i mod 数据长度。当多个值要放在同一个位置时，在下面接链表。

▪ LinkedHashMap – 有序的HashMap 速度快  采用链表

 ▪ TreeMap – 有序 速度没有hash快 采用红黑树

 ▪ 问题：Set与Map有关系吗？ – 采用了相同的数据结构，	Set只用于map的key存储数据,以上是Set

```java
* map存储的是k-v键值对映射的数据
*      实现子类：
*          HashMap：数据+链表（jdk1.7） 数组+链表+红黑树（jdk1.8）
*          LinkedHashMap：链表
*          TreeMap:红黑树
*
*      基本api操作：
*          增加：
*              put（k,v）    添加元素
*          查找：
*              isEmpty      判断是否为空
*              size        返回map的大小
*              containsKey  判断是否包含给定key
*              containsValue 判断是否包含给定value
*              get("key")          通过"key"获取对应数value
*          删除：
*              clear 清空集合中的所有元素
*              remove:删除指定元素
*     Map.entry:外面是集合，里面表示的是K-V组合的一组映射关系，key和value成组出现

        Set<Map.Entry<String, Integer>> entries = map.entrySet();
        Iterator<Map.Entry<String, Integer>> iterator1 = entries.iterator();
        while (iterator1.hasNext()){
            Map.Entry<String, Integer> next = iterator1.next();
            System.out.println(next.getKey()+"--"+next.getValue()); //直接用next即可
        }

        //遍历操作
        Set<String> keys = map.keySet();
        for(String key:keys){
            System.out.println(key+"="+map.get(key));
        }

        //只能获取对应的value值，不能根据value来获取key
        Collection<Integer> values = map.values();
        for (Integer     i:values){
            System.out.println(i);
        }

        //迭代器
        Set<String> keys2 = map.keySet();
        Iterator<String> iterator = keys2.iterator();
        while(iterator.hasNext()){
            String key = iterator.next();
            System.out.println(key+"="+map.get(key));
        }
        
*     hashmap跟hashtable的区别：
*      1、hashmap线程不安全，效率比较高，hashtable线程安全，效率低
*      2、hashmap中key和value都可以为空,hashtable不允许为空 map.put(null,null)
*
*
hashmap源码：
public class HASHMAP<k,v>{
    static final int DEFAULT_INITIAL_CAPACITY = 1<<4; 
    //容量DEFAULT_INITIAL_CAPACITY必须为2的n次幂，如果没设置，默认16
    static final int MAX_CAPACITY = 1<<30; 
    static final float DEFAULT_LOAD_FACTOR = 0.75f //默认加载因子，当存的数据量到达最大容量*加载因子时，要进行扩容，扩容成二倍，这样扩容后还可以保证是2的N次幂
}
*      hashmap初始值为2的N次幂，
*          1、因为采用除法散列法，方便进行&操作，提高效率，&要比取模运算效率要高,设成2的N次幂可以保证二进制数全为1，方便与运算
*              return hash & (initCapacity-1) 等价于 hash % (initCapacity-1)
*          2、扩容每次扩容二倍，在扩容之后涉及到元素的迁移过程，扩容后多了一位参与与运算：迁移的时候只需要判断二进制的前一位是0或者是1即可，
*              这一位如果是0，表示新数组和就数组的下标位置不变，如果是1，只需要将索引位置加上旧的数组的长度值即为新数组的下标，这样比&运算更快，也是为什么要设置成2的N次幂的另一个原因
*      1.7源码知识点：  数组+链表
*          1、默认初始容量
*          2、加载因子
*          3、put操作
*              1、设置值，计算hash
*              2、扩容操作
*              3、数据迁移的过程
         4、哈希碰撞：假如size为16，那么key的值范围为0000-1111，假如k1：10101001、k2：11001001，k1≠k2，但放进去的只是后四位，导致k1=k2，即元素堆叠，即哈希碰撞。简单解决方法；右移4位，取前四位
*      1.8源码知识点:采用的数据结构不同   数组+链表+红黑树
```

<img src="C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211210212558414.png" alt="image-20211210212558414" style="zoom:33%;" />

<img src="C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211210212621206.png" alt="image-20211210212621206" style="zoom: 25%;" />

put元素流程：

![image-20211210213211989](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211210213211989.png)

<img src="C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211210213135360.png" alt="image-20211210213135360" style="zoom:33%;" />

### 插入排序：

盯着的位置（数组下标）（从第二个数开始，先是第二个数和第一个数相比）往前看，如果比你大，则交换，如果小于等于你，则不交换  ，每个数直至换到左面没有数字或者不交换为止

选择排序法的复杂度：当数据状况会影响算法性能程度，那么一定要用最差情况表示 → O（n2）

- 时间复杂度：当处理样本量很大的时候最重要的试最高阶项是什么


- 额外空间复杂度：（用户给你的不算额外空间）完成算法流程需要额外开辟的空间数量 


- 一个问题的最优解：先要保证时间复杂度尽量低，先满足了时间复杂的的指标后，再保证空间复杂度尽量低（一般常数项）




### 对数器：

你想测的方法a，实现复杂度不好但是容易实现的方法b，实现一个随机样本产生器，生成随机数据在a和b思路下运行，看得到结果是否一样，若有一个随随机样本使得比对结果不同，打印样本进行人工干预，改对方法a和方法b，当样本数量很多时比对测试仍正确，可以确定方法a正确。

Math. random →[0,1）所有的小数，等概率返回一个

Math. random*N →[0,N）所有的小数，等概率返回一个

(int)(Math. random*N) →[0,N）所有的整数，等概率返回一个

### 二分法：

O（log2N）16→8→4→2→1 二分的次数为log2N，每次找到终点看一眼大小的复杂度为O（1），

代码写法： mid=（L+R）/2不安全！因为R、L很大时L+R可能会溢出！mid=L+（R-L）>> 1;位运算比除法快得多！

```java
while (L<R){ //L到R范围至少有两个数
    mid =L+((R-l)>>1);
    if(sortedArr[mid] == num){
        return true;
    }else if(sortedArr[mid] > num){
        R=mid - 1;
    }else{
        L=mid + 1;
    }
}
return sortedArr[L] == num; //最后验证一下
```

在无序数组（任意两相邻数不相等）中找局部最小值问题：（不一定要有序才能二分，只要能构建出类似于排他性的时候就能用二分）

```java
if (arr.length == 1 || arr[0] < arr[1]){
   return 0;
}
if (arr[arr.length-1]<arr[arr.length-2]{
   return arr.length-1;
})
int L=1,R=arr.length-2;
while (L<R){ //L到R范围至少有两个数
    mid =(L+R)/2;
    if(arr[mid-1] < arr[mid]){
        R=mid-1; //切取左侧，不看右侧
    }else if(arr[mid] > arr[mid+1]){
        L=mid+1; //切取右侧，不看左侧
    }else{
        return mid; //mid即为最小值
    }
}
return L; //因为L到R范围内至少有2个
```



### 异或运算

性质：0与任何数异或都是其本身；任何数与其本身异或都为零；交换律和结合律

1、如何不用额外变量交换两个变量的值？→异或运算（异或效率是最高的，比加减乘除快）

```
a=a^b; //a=甲异或乙，b=乙
b=a^b; //a=甲^乙，b=甲^(乙^乙)=甲^0=甲
a=a^b; //a=甲^乙^甲=甲^甲^乙=0^乙=乙
```

在数组中用异或交换数值：i与j不能相同！！因为i与j需要指向不同的内存区域！否则运行结果为0。

2、一个数组中只有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

法一：哈希表遍历统计

法二：申请变量eor=0,eor异或数组中每个数(运用异或结合律)

```
arr[]=[a,b,a,c,...];
int eor=0,i=0;
while(i<arr.length){
    eor=eor^arr[i];
    i=i+1;
} 
System.out.println(eor);
//返回eor的值就是那个出现了奇数次的数
```

3、怎么把整形数字最右侧的1提取出来？→a&(~a+1)=a&(-a)

​      a=01101110010000

​    ~a=**100100011**0**1111**  左面取反，右面都变成1

~a+1=10010001110000

  ans=00000000010000

4、一个数组中有2种数a、b（a不等于b）出现了奇数次，其他数出现了偶数次，找到并打印这两种数

准备eor=0，从头异或到尾 ，则eor=a^b;

找出eor‘最右侧的1，见3，a与b在这一位上一定是不同的，也可以按此标准把数组中的数分成两类（设b这一位是0，a这一位是1）这两类数里也会有出现了偶数次的那些数，也是互斥的

再申请一个变量eor’，只挑这一位是1的那一类数和eor’异或，最终eor‘=a。

eor^eor‘=b

```java
int eor=0;
for (int i=0;i<arr.length;i++){
    eor ^= arr[i];
}
int rightOne=eor&(-eor); //rightone=000000001000
int onlyOne=0; //eor'
for(int i=0;i<arr.length;i++){
   if ((arr[i]&rightOne)!=0){ //使用与运算，那些数在这位上一定是1！
   onlyOne ^= arr[i];
   }
}
System.out.println(onlyOne +" "+(eor^onlyOne));
```

5、一个数组中只有一种数出现了k次，其他数都出现了m次，m>1，k<m，找出出现了k次的数字，要求额外空间复杂度O（1），时间复杂度O（N）

java中整形数32位，任何一个整数都可以转换为数组形式的二进制表示，把数组中所有的数组的二进制表示都按位累加起来，若某一位不能被m整除，那么其mod m之后的余数就是k。（k<m时才成立）

```java
int[] t=new int[32];
//t[i]: i位置的1出现了几个; 
for (int num : arr){
    for (int i=0;i <= 31;i++){
       //if (((num>>i)&1)!=0){ // num>>i:第i位的数字被移到最后一位; 即第i位不是零;
       //   t[i]++;
        t[i]+=(num>>i)&1; //优化
       }
    }
}//时间复杂度还是O(n),因为内循环执行了有限次数
int ans=0;//额外空间复杂度O(1),设为0为了填答案
for(int i=0; i<32; i++){
    if(t[i] % m != 0){ //说明这个数在第i位上有1
        ans += (1<<i); //依次把这个数有1的各个位设置上去
    }
}
return ans;
```

建立测试样例（哈希表方法）：

```java
public static int test(int[] arr, int k, int m){
    HashMap<Integer, Integer> map=new HashMap<>();
    for (int num : arr){
        if(map.containsKey(num)){
            map.put(num, map.get(num)+1);
        }else{
            map.put(num,1);
        }
    }
    for(int num:map.keySet()){
       if (map.get(num)==k){
           return num;
       }
    }
    return -1;
}
//对数器：
public static int[] randomArray(int maxlen, int range, int k, int m){
    int ktimeNum=randomNumber(range);
    //int times = Math.random()<0.5 ? k :((int)Math.random()*(m-1))+1;将k随机化：之后将k都换为times
    int numKinds = (int)(Math.random()*maxKinds) + 2;//数组长度：k*1+(numKinds-1)*m
    int[] arr = new int[k+(numKinds-1)*m];
    int index=0;
    for(;index<k;index++){
        arr[index]=kTimeNum;
    } //从0~k-1填了k个进去
    numKinds--; //还剩这么多种数要填
    HashSet<Integer> set = new HashSet<>();//一定要建立哈希表！ why？
    set.add(kTimeNum); //把出现k次的数加入哈希表
    while(numKinds != 0){
        int curNum = 0;
        do {
            curNum = randomNumber(range);
        }while(set.contains(curNum));//保证每次骰出的数都是新的
        set.add(curNum);
        numKinds--;
        for(int i=0;i<m;i++){
            arr[index++] = curNum;//index是继承的
        }
    }//arr 填好了
    //将数据打乱
    for(int i=0;i<arr.length;i++){//i位置的数随机与j位置的数交换
        int j = (int)(Math.random()*arr.length);
        int tmp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp; 
    }
    return arr;
}
public Static int randomNumber(int range){
    return ((int)(Math.radom()*range)+1)-((int)(Math.radom()*range)+1);//生成随机的正负数
}
public static void main(String[] args){
    int kinds=10;
    int range=200;
    int testTime = 100000;
    int max=9;
    System.out.println("测试开始")；
    for(int i=0; i<testTime;i++){
        int a=(int)(Math.random()*max)+1; //a=1~9
        int b=(int)(Math.random()*max)+1; //b=1~9
        int k=Math.min(a,b);
        int m=Math.max(a,b); //k<m
        if(k == m){
            m++;
        }
        int[] arr=randomArray(kinds, range, k, m);
        int ans1 = test(arr,k,m);
        int ans2 = onlyKTimes(arr,k,m);
        if(ans1!=ans2){
            System.out.println(ans1);
            System.out.println(ans2);
            System.out.println("出错了");
        }
    }
    System.out.println("测试结束");
}
```

### 一些基础的数据结构

#### 链表

单向链表（可以实现成泛型）

```java
public class Node(
    public int value; // int可以变为泛型T
    public Node next;
    public Node(int data){
        value = data;
    }
)
```

双向链表

```java
public class DoubleNode(
    public int value; // int可以变为泛型T
    public DoubleNode last;
    public DoubleNode next;
    public DoubleNode(int data){
        value = data;
    }
)
```

单链表反转：

①头结点next指针指向空  ②后面节点的next指针依次指向前面那个节点  ③头指针指向末尾的节点（确保所有结点均可达！不然会被释放掉！）

```java
// a→b→c→null     c→b→a→null
public static Node reverseLinkedList(Node head){
    Node pre = null;
    Node next = null;
    while (head!=null){  //第一次循环，此时head指向a
        next=head.next;  //next = b
        head.next=pre;  //a的next指针verdse指向空区域
        //head.last = next //加上此行为双链表反转
        pre=head;  //pre指向a
        head=next; //head指向b
    }
    return pre; //最终pre指向c
}
//调用：
n1 = reverseLinkedList(n1);
```

删除链表中指定值结点（一定要设置返回值，返回头结点）（注意边界条件）

```java
public static Node removeValue(Node head, int num) {
		// head来到第一个不需要删的位置
		while (head != null) {
			if (head.value != num) {
				break;
			}
			head = head.next;
		}
		// 1 ) head == null，链表中全是member这个值
		// 2 ) head != null
		Node pre = head;
		Node cur = head;
		while (cur != null) {
			if (cur.value == num) {
				pre.next = cur.next;// pre的next指针指向当前结点
			} else {
				pre = cur;
			}
			cur = cur.next;
		}
		return head;
}
```

#### 栈和队列

逻辑概念

栈：数据先进后出，犹如弹匣（一个数组＋一个index(控制下一个进来的数据放的位置））

队列：数据先进先出，好似排队 （用双向链表、数组也可以实现）

用单链表实现队列：

```java
public void push(V value) { //入队列
   Node<V> cur = new Node<>(value);
   if (head == null) {
      head = cur;
   } else {
      cur.next = head;
      head = cur;
   }
   size++;
}

public V pop() { //出队列
   V ans = null;
   if (head != null) {
      ans = head.value; //只返回头结点的值
      head = head.next; //头结点指向下一个结点
      size--;
   }
   if (head == null){ //已经把所有数都弹完了   
       tail = null; //尾巴和头保持一致，都指向空。否则尾还指向最后一个元素！
   }
   return ans;
} //O(1)
```

用循环数组实现队列：（设置两个指针，begin来到最早数的位置，end来到最末尾的位置，用户取数时从begin取，用户加数时从end加，end和begin在互相追赶，end与begin之间有距离，那么可以放数字）（这样很繁琐）→再设置一个size变量，让begin与end解耦掉

```java
public static class MyQueue {
		private int[] arr;
		private int pushi;// end 进来的数字放哪
		private int polli;// begin 出去的数字从哪出
		private int size;
		private final int limit;
		public MyQueue(int limit) {
			arr = new int[limit];
			pushi = 0;
			polli = 0;
			size = 0;
			this.limit = limit;
		}
		public void push(int value) {
			if (size == limit) {
				throw new RuntimeException("队列满了，不能再加了");
			}
			size++;
			arr[pushi] = value; //把新进来的数放到pushi位置
			pushi = nextIndex(pushi);
		}
		public int pop() { //弹出数据
			if (size == 0) {
				throw new RuntimeException("队列空了，不能再拿了");
			}
			size--;
			int ans = arr[polli];
			polli = nextIndex(polli);
			return ans;
		}
		public boolean isEmpty() {
			return size == 0;
		}
		// 如果现在的下标是i，返回下一个位置
		private int nextIndex(int i) {
			return i < limit - 1 ? i + 1 : 0; //i到了最后返回0，否则返回i+1
		}
	}
```

用双向链表实现双端队列：(单链表不支持双端队列，因为跳不回去，尾结点无法找到之前的值)



常见面试题：

1、实现一个特殊栈，在基本功能基础上，实现返回栈最小元素的功能（时间复杂度为O（1））

方法：准备两个栈（数据栈、最小栈），相当于一种同步记录

压入数据栈的当前数比最小栈的栈顶小，压入最小栈，否则重复压入最小栈栈顶的数

2、如何用栈结构实现队列结构？（双栈队列）

注意：把push栈里的数据一次性倒完到pop栈里；只有pop栈空了，才能倒数据。

```java
public static class TwoStacksQueue {
		public Stack<Integer> stackPush; //建立两个栈
		public Stack<Integer> stackPop;

		public TwoStacksQueue() {
			stackPush = new Stack<Integer>();
			stackPop = new Stack<Integer>();
		}
		private void pushToPop() { // push栈向pop栈倒入数据
			if (stackPop.empty()) {
				while (!stackPush.empty()) { //倒到push栈完全空
					stackPop.push(stackPush.pop());
				}
			}
		}

		public void add(int pushInt) {
			stackPush.push(pushInt); //先加到push栈
			pushToPop(); //检查你能不能倒数据
		}

		public int poll() { //弹数据
			if (stackPop.empty() && stackPush.empty()) {
				throw new RuntimeException("Queue is empty!");
			}
			pushToPop();
			return stackPop.pop();
		}

		public int peek() {
			if (stackPop.empty() && stackPush.empty()) {
				throw new RuntimeException("Queue is empty!");
			}
			pushToPop();
			return stackPop.peek();
		}
	}
```

如何用队列结构实现栈结构？

用两个栈如：A队列加数据，如12345（1先进），用户要弹出5，那么1234进B（辅助队列），5在A中弹出；把A和B队列互换，用户又给了6和7，要弹出7，那么把A的12346放到B里，留7在A里弹出

```java
public static class TwoQueueStack<T> {
		public Queue<T> queue;
		public Queue<T> help;

		public TwoQueueStack() {
			queue = new LinkedList<>();//新建两队列
			help = new LinkedList<>();
		}

		public void push(T value) {
			queue.offer(value); //加入数据，不需要倒队列
		}

		public T poll() {
			while (queue.size() > 1) { //q只剩一个数据的时候停
				help.offer(queue.poll()); //把queue里的数据倒到help里
			}
			T ans = queue.poll(); //queue最后一个数据作为answer返回
			Queue<T> tmp = queue;  //q跟h引用的内存地址互换
			queue = help;
			help = tmp;
			return ans;
		}

		public T peek() {
			while (queue.size() > 1) {
				help.offer(queue.poll());
			}
			T ans = queue.poll();
			help.offer(ans);
			Queue<T> tmp = queue;
			queue = help;
			help = tmp;
			return ans;
		}

		public boolean isEmpty() {
			return queue.isEmpty();
		}
}
```

3、递归问题（任何递归一定都可改成非递归）

```java
// 例：求arr中的最大值
	public static int getMax(int[] arr) {
		return process(arr, 0, arr.length - 1);
	}

	// arr[L..R]范围上求最大值  L ... R   N
	public static int process(int[] arr, int L, int R) {//base case：递归如何结束
		// arr[L..R]范围上只有一个数，直接返回
		if (L == R) { 
			return arr[L];
		}
		// L...R 不只一个数
		// mid = (L + R) / 2
		int mid = L + ((R - L) >> 1); // 中点   	1
		int leftMax = process(arr, L, mid);  //19行 调用递归
		int rightMax = process(arr, mid + 1, R);
		return Math.max(leftMax, rightMax);
	}
```

- 递归如何运行？

  假如arr=【5，6，7，2】,最终返回值为f(arr,0,3)的值

  18行：mid = 1

  19行：leftmax = f(arr,0,1),又调用了递归，这时把f(arr,0,3)以及中间产生的所有临时变量（f(arr,0,3)、mid=1，leftmax = f(arr,0,1)）压入到系统栈里，把整个行为销毁，然后运行f(arr,0,1)这个新过程，f(arr,0,1)需要调用f(arr,0,0),同时继续把f(arr,0,1)及临时变量压入系统栈，但是f(array,0,0)的L等于R，返回5，把系统栈栈顶元素弹出，恢复成函数现场，leftmax=5，

  <img src="C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211201111907955.png" alt="image-20211201111907955" style="width:400px" />

  20行：和19行流程类似，rightmax=f(arr,1,1),继续把临时变量压入系统栈，然后运行f(arr,1,1),f(arr,1,1)=6，栈顶元素弹出，ringhtmax=6，系统栈栈顶元素弹出，运行21行，求一最大值6，弹出栈的内容，leftmax=f(arr,0,1)=6, 然后又要调用f（arr，2,3)，继续把它压进去，周而复始。

  <img src="C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211201113152994.png" alt="image-20211201113152994" style="width:400px;" />

  ​                                                                        实际调用

  <img src="C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211201115500395.png" alt="image-20211201115500395" style="width:400px;" />

  ​                                                                          逻辑调用

Master公式：分析递归函数时间复杂度

T(N)=子过程发生次数*子过程复杂度+递归之外行为的时间复杂度（**只需展开一步即可**）**（注意：此公式必需在子问题规模都一致时才能使用）**
$$
T(N)=a*T(N/b)+O(N^d)
$$
(1)若logb(a)  < d, O(N^d)

(2)若logb(a)  > d, O(N^logb(a))

(3)若logb(a) == d, O(N^(d*log2(N)))

#### 哈希表

哈希表增删改查复杂度不管内部数据量有多大，复杂度都是O(1)，但是常数有点大

哈希表里只记录内存地址，占用8字节，而不记录数据本身。

```java
public static class Zuo {
	public int value;
	public Zuo(int v) {
		value = v;
	}
} //非原生类型
public static void main(String[] args) {
	HashMap<Integer, String> test = new HashMap<>(); //原生的类型Integer、string
	Integer a = 19000000;
	Integer b = 19000000; //引用
	System.out.println(a == b); //会返回false，因为"="是按照引用传递的，但是原生类型在哈希表中是按照值传递的
    test.put(a, "我是3");
	System.out.println(test.containsKey(b)); //返回true
    Zuo z1 = new Zuo(1);
	Zuo z2 = new Zuo(1);
	HashMap<Zuo, String> test2 = new HashMap<>();
	test2.put(z1, "我是z1");
	System.out.println(test2.containsKey(z2)); //查询哈希表中有无z2，会返回false，因为这时哈希表按引用传递，只认内存地址
}
```

#### 有序表

有序表是一个接口名，红黑树、avl、sb树、跳表，都可实现，增删改查 O(logN)， java中是用红黑树实现的

```java
TreeMap<Integer, String> treeMap = new TreeMap<>();
treeMap.put(3, "我是3");
treeMap.put(4, "我是4");
treeMap.put(8, "我是8");
treeMap.put(5, "我是5");
treeMap.put(7, "我是7");
treeMap.put(1, "我是1");
treeMap.put(2, "我是2");

System.out.println(treeMap.containsKey(1));
System.out.println(treeMap.containsKey(10));
System.out.println(treeMap.get(4));
System.out.println(treeMap.get(10));
treeMap.put(4, "他是4");
System.out.println(treeMap.get(4));
		// treeMap.remove(4);
System.out.println(treeMap.get(4));
System.out.println("新功能：");
System.out.println(treeMap.firstKey());
System.out.println(treeMap.lastKey());
		// 查询<= 4且离4最近的key,对于系统原生内置的数据类型，哈希表知道怎么排序
System.out.println(treeMap.floorKey(4)); 
		// 查询>= 4且离4最近的key
System.out.println(treeMap.ceilingKey(4));
		// 复杂度：O(logN)
TreeMap<Zuo, String> zuoMap = new TreeMap<>(); //对于自定义的数据结构，必需写出怎么排序（比较器作为参数传进去），否则会报错，
zuoMap.put(z1, "woshiz1")
zuoMap.put(z1, "woshiz1")
```

### 归并排序

f(arr,L,R)上有序：①求中点M=(L+R)/2  ②f(arr,L,M)有序 ③f(arr,M,R)有序 ④merge整体有序  O（N）

（左右指针不回退，拷贝数据也是O（N））

递归方法实现：

```java
// T(N) = 2 * T(N / 2) + O(N)
// O(N * logN) → O(N^2) : 每一次只选出一个最小值，上一次的比较行为无法加速之后的比较行为，merge操作的每一次比较都是作为结果在传递
public static void process(int[] arr, int L, int R) {
		if (L == R) { // base case
			return;
		}
		int mid = L + ((R - L) >> 1);
		process(arr, L, mid);
		process(arr, mid + 1, R);
		merge(arr, L, mid, R);//调用merge是L到M、M+1到R已经分别有序了
}
public static void merge(int[] arr, int L, int M, int R) {
		int[] help = new int[R - L + 1]; //准备辅助数组
		int i = 0;
		int p1 = L; //左部分指针
		int p2 = M + 1; 
		while (p1 <= M && p2 <= R) { //P1、P2都不越界时
			help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
		}//P1指向的数小于p2指向的数，将p1指向的数拷贝，将p1向后移动一位，否则p2执行p1的操作
		// 注意：：要么p1越界了，要么p2越界了，下面两个while只会发生一个
		while (p1 <= M) {//p1未越界
			help[i++] = arr[p1++];
		}
		while (p2 <= R) {//p2未越界
			help[i++] = arr[p2++]; //谁不越界谁把剩下的数拷贝到help里面去
		}
		for (i = 0; i < help.length; i++) {
			arr[L + i] = help[i];
		}
}
```

 迭代方法实现：

规定一个步长，在每个步长内做merge，之后把步长2，再做merge，以此类推。若步长不够，则取不够的那些数merge。步长变log2(N)次，每次O(N)，所以复杂度O(N*log2(N))

```java
public static void mergeSort2(int[] arr) {
	if (arr == null || arr.length < 2) {
		return;
	}
	int N = arr.length;
	int mergeSize = 1;// 步长
	while (mergeSize < N) { // log N
			// L为当前左组的，第一个位置
		int L = 0;
		while (L < N) {
            int M = L + mergeSize - 1; //当前左组最后一个数（如果够的话应该到哪）
			if (M>=N){
               break; 
            }
			int R = Math.min(M+mergeSize, N - 1); //右组最后一个数的位置，如果够：到M+步长的位置，不够：到数组最后一位，即N—1。
			merge(arr, L, M, R);//左组：L……M 右组：L+1……R
			L = R + 1; //下一个左组第一个数
		}
			// 数N可能非常靠近整数最大值，可能步长*2就溢出了这个值，防止步长溢出变成负数：
		if (mergeSize > N / 2) {
			break;
		}
		mergeSize <<= 1; //mergesize*2
	}
}
```

归并排序的应用：

1、小和问题：对于一个数组中，将数组中每个元素左面比它小的数求和：要求复杂度O(Nlog(N))。

等价于：假设i位置上的数为a，如果a右面有x个数字比a大，产生x个a，

**一个数x先遭遇一个最近的右组，求出有几个数比x大，有序后，再遭遇一个更大的右组，依次类推，对每个数都如此计算，x内部组的数是不产生小和的，当相等的时候先拷贝右面的**

```java
public static int smallSum(int[] arr) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		return process(arr, 0, arr.length - 1);
}

// arr[L..R]既要排好序，也要求小和返回
	// 所有merge时，产生的小和，累加
	// 左 排序   merge
	// 右 排序  merge
	// merge
public static int process(int[] arr, int l, int r) {
		if (l == r) {
			return 0;
		}
		// l < r
		int mid = l + ((r - l) >> 1);
		return 
				process(arr, l, mid) //左面排序产生的小和总量
				+ 
				process(arr, mid + 1, r) //右面排序产生的小和总量
				+ 
				merge(arr, l, mid, r); //merge过程产生的小和总量
}
public static int merge(int[] arr, int L, int m, int r) {
		int[] help = new int[r - L + 1];
		int i = 0;
		int p1 = L;
		int p2 = m + 1;
		int res = 0; //小和数量
		while (p1 <= m && p2 <= r) {
			res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;//左组小于右组，累加那么多个小和到result上，否则不累加
			help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];//左组小于右组时才拷贝左组，否则拷贝右组
		}
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[L + i] = help[i];
		}
		return res; //返回值
}
```

2、逆序对问题：

在一个数组中，任何一个左边的数和一个右边的数只要降序就是一个逆序对

3、num的右面有多少个数×2后依然＜num

（1，4，6，8，9，1，1，2，3，3，4）不回退技巧：使左组和右组有序，

```java
public static int merge(int[] arr, int L, int m, int r) {
		// 左组[L....M]   右组[M+1....R]
		
		int ans = 0;
		// 目前囊括进来的数，是从[M+1, windowR) 左闭右开
		int windowR = m + 1; //windowR是指你到不了的位置，不是指滑到哪了
		for (int i = L; i <= m; i++) { //依次考察所有左边组的数能滑到哪
			while (windowR <= r && arr[i] > (arr[windowR] * 2)) {
				windowR++;
			}
			ans += windowR - (m + 1);
		}
			
		int[] help = new int[r - L + 1];
		int i = 0;
		int p1 = L;
		int p2 = m + 1;
		while (p1 <= m && p2 <= r) {
			help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
		}
		while (p1 <= m) {
			help[i++] = arr[p1++];
		}
		while (p2 <= r) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[L + i] = help[i];
		}
		return ans;
	}
```

本质：mergesort把比较操作变成了有序信息，掌握：手写代码！

### 堆和堆排序

#### 比较器

比较器实质就是重载运算符

比较器可以很好的应用在特殊标准的排序上、特殊标准排序的结构上

写代码变得容易，还用于范型编程

```java
// 性能：N * logN
// 如果自己定义的类一定要设置比较器，不然系统不知道如何比较
```

```java
// 任何比较器：
	// compare方法里，遵循一个统一的规范：
	// 返回负数的时候，认为第一个参数应该排在前面
	// 返回正数的时候，认为第二个参数应该排在前面
	// 返回0的时候，认为无所谓谁放前面
public static class idjiangOrder implements Comparator<Student>{
    @Override
	public int compare(Student o1, Student o2) {
		return o2.id - o1.id;
	}
}

public static class IdShengAgeJiangOrder implements Comparator<Student> {
	// 根据id从小到大，但是如果id一样，按照年龄从大到小
	@Override
	public int compare(Student o1, Student o2) {
		return o1.id != o2.id ? (o1.id - o2.id) : (o2.age - o1.age);
	}
}
Student[] students = new Student[] { student1, student2, student3, student4, student5 };

Arrays.sort(students, new IdShengAgeJiangOrder());
for (int i = 0; i < students.length; i++) {
	Student s = students[i];
	System.out.println(s.name + "," + s.id + "," + s.age);
}
```

用于有序表：

```java
Student student1 = new Student("A", 4, 40);
Student student2 = new Student("B", 4, 21);
Student student3 = new Student("C", 3, 12);
Student student4 = new Student("D", 3, 62);
Student student5 = new Student("E", 3, 42);
TreeMap<Student, String> treeMap = new TreeMap<>(new IdShengAgeJiangOrder);
//括号里也可以写成(a,b) -> a.id - b.id (按照升序排列)
//treemap 如果两个对象一样，那么不重复加入，所以只有关于id=3和id=4的两个人（因为比较器只考虑id)
//把id相同的所有对象都留下来：(a,b) -> a.id != b.id ? (a.id-b.id) : (a.(hashCode()-b.hashCode()));
treeMap.put(student1, "我是学生1，我的名字叫A");
treeMap.put(student2, "我是学生2，我的名字叫B");
treeMap.put(student3, "我是学生3，我的名字叫C");
for (Student s : treeMap.keySet()) { //按照你规定的顺序遍历
	System.out.println(s.name + "," + s.id + "," + s.age);
}
```

#### 堆结构heap(优先级队列）：

- 完全二叉树：上面的层一定是满的，如果有不满的层，那么一定是最后一层，不满的层也是从左往右依次变满的状态，空树算完全二叉树；

- 用数组实现完全二叉树：规律：i位置的左孩子的位置在2×i+1，右孩子2×i+2，父亲（i-1)/2向下取整。size：只认为0~size位置的数在树上存在（树长到什么地步）
- 堆：①堆是完全二叉树  ②大根堆：在一棵完全二叉树中，每一颗子树的最大值都满足：是子树头结点的值；小根堆：在一棵完全二叉树中，每一颗子树的最小值都满足：是子树头结点的值
- 堆元素上升：(0~i-1)堆已经排序好，当i来时，i先与其父亲比较，若i大于父亲，则交换，否则不交换，当i移动到根结点时停止，或i小于其父亲时停止。(上移过程heapinsert)

```java
// 新加进来的数，现在停在了index位置，请依次往上移动，
		// 移动到0位置，或者干不掉自己的父亲了，停！
private void heapInsert(int[] arr, int index) {
		//当前数： [index]    父亲：[index-1]/2
		// index == 0：自己的父亲和自己是一个数，停止。
	while (arr[index] > arr[(index - 1) / 2]) {
		swap(arr, index, (index - 1) / 2); //和自己父亲交换
	    index = (index - 1) / 2; //下标移动到父亲位置
	}
} //复杂度：O(logN) 因为完全二叉树的高度为logN，x直往一侧移动，移动的次数与高度相关
```

- 堆元素下沉：用户随时pop出最大值，同时剩余维持堆的状态。先将堆顶保存到一个临时变脸t中，再令堆中最后一个数与第一个数交换，再令heapsize-1，等同于最后一个数与堆断开了。

```java
// 从index位置，往下看，不断的下沉
// 停：较大的孩子都不再比index位置的数大；已经没孩子了
private void heapify(int[] arr, int index, int heapSize) {
		int left = index * 2 + 1; //左孩子下标
		while (left < heapSize) { // 如果有左孩子，有没有右孩子，可能有可能没有！
			// 把较大孩子的下标，给largest
		int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left; //如果右孩子不越界，并且右孩子的值大于左孩子的值，把右孩子的下标给largest
		largest = arr[largest] > arr[index] ? largest : index;//较大孩子值比父亲大，把自己下标给largest，否则父亲下标给largest
		if (largest == index) { //index下标值不需要往下沉
			break;
		}
		// index和较大孩子，要互换
		swap(arr, largest, index);
		index = largest;
		left = index * 2 + 1;
		}
} 
```

一个已经排好的堆，其中有一个数发生了变化，把此序列再调成堆：只需要依次执行heapinsert和heapify两个函数，即可完成。

```java
public static class MyComparator implements Comparator<Integer>{
		@Override
		public int compare(Integer o1, Integer o2) {
			return o2 - o1;
		}
	}   //重新定义比较器，把小根堆变为大根堆
	
	public static void main(String[] args) {
		// 默认为小根堆
		PriorityQueue<Integer> heap = new PriorityQueue<>(new MyComparator());
		heap.add(5);
		heap.add(5);//堆结构可以加重复值，有序表不可以加重复值
		heap.add(5);
		heap.add(3);
		//  5 , 3
		System.out.println(heap.peek());
		heap.add(7);
		heap.add(0);
		heap.add(7);
		heap.add(0);
		heap.add(7);
		heap.add(0);
		System.out.println(heap.peek());
		while(!heap.isEmpty()) {
			System.out.println(heap.poll());
		} //按顺序打印堆中元素
```

- 堆排序：整个数组是无序的，需要让他有序。

  假设数据是一个一个给你的，先把整个数组弄成大根堆，从上到下的过程时间复杂度为N×logN，从下到上的方法，时间复杂度为O(N)

  再把0和N-1的位置的数交换，把N-1位置的数与整个堆断掉(size-1),最大值就一直放在N-1位置上不动，再把(0,N-2)范围的数弄成大根堆，再把0和N-2位置上的数交换……周而复始，这一步时间复杂度O(NlogN)

  堆的大小减小成0后，排序完成

```java
public static void heapSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		for (int i = 0; i < arr.length; i++) { // O(N)
			heapInsert(arr, i); // O(logN)
		}  //从上到下整个数组调成大根堆，// O(N*logN) 
		
		for (int i = arr.length - 1; i >= 0; i--) {
			heapify(arr, i, arr.length);
		}/从下到上整个数组调成大根堆，// O(N*logN)
		int heapSize = arr.length; //数组整体
		swap(arr, 0, --heapSize); //全局最大值被换到N-1位置上且已经断连
		// O(N*logN)
		while (heapSize > 0) { // O(N)
			heapify(arr, 0, heapSize); // O(logN)
			swap(arr, 0, --heapSize); // O(1)
		}
	}
```

堆排序复杂度：O(NlogN)

从下到上建堆：复杂度O(N)，假设一共有N个结点，第二层叶子结点有N/2个

T(N)=N/2*1+N/4×2+N/8×3+N/16×4+……   （收敛于O(N)） 1，2，3，4为层数

从上往下建堆时，大量结点是高度增加后建上去的，而从下往上大量的结点是层数少的，所以复杂度低。

#### 加强堆

笔试要求：C/C++ 1~2s ,Java 2~4s代码量10^8以内

线段问题：有N条开始位置、结束位置为整数的线段，返回重合区域（长度必须大于等于1）最多的线段数量。

（暴力方法：重合区域必包含0.5，依次考察1.5，2.5，3.5……，有多少个线段包含，再求最大值）时间复杂度：O((max-min)*N)

（巧方法：所有线段按**开始位置**用比较器从小排到大，准备一个小根堆，排完序依次考察每个线段，遍历到任何一个线段时，在小根堆里把所有≤开始位置的值全弹出【小根堆里存的数字是之前线段的结尾，把之前的线段的结束位置≤此线段开始位置的线段全部删除】然后把此时线段结束位置加到小根堆里，然后看看小根堆里有几个数就是这个线段的答案。然后再求答案最大值）【重合区域左边界必是一条线段左边界】

```java
    public static int maxCover2(int[][] m) {
		Line[] lines = new Line[m.length]; //新建线段数组
		for (int i = 0; i < m.length; i++) {
			lines[i] = new Line(m[i][0], m[i][1]); 
		}
		Arrays.sort(lines, new StartComparator()); //按比较器排序
		// 新建一个空的小根堆，每一条线段的结尾数值，使用默认的
		PriorityQueue<Integer> heap = new PriorityQueue<>();
		int max = 0;
		for (int i = 0; i < lines.length; i++) {
			// lines[i] -> cur  在黑盒中，把<=cur.start 东西都弹出
			while (!heap.isEmpty() && heap.peek() <= lines[i].start) { //堆里有结尾且结尾不如我的开头大，则弹出
				heap.poll();
			}
			heap.add(lines[i].end); //把自己的结尾放进小根堆
			max = Math.max(max, heap.size()); //更新max
		}
		return max;
	} //N条线段结尾位置只会进一次小根堆，弹出一次小根堆，小根堆每一次调整代价是logN级别，
所以复杂度O(N*logN)
   public static class Line { //线段类
		public int start;
		public int end;

		public Line(int s, int e) {
			start = s;
			end = e;
		}
	}
//开始位置的比较器
    public static class StartComparator implements Comparator<Line> {
		@Override
		public int compare(Line o1, Line o2) {
			return o1.start - o2.start;
		}
	}
```

手写堆：

- 为什么要有手写堆？

  系统提供的堆无法做到的事情：

  （1）已经入堆的元素，如果参与排序的指标方法变化，系统提供的堆无法做到时间复杂度O(logN)调整，都是O(N)的调整！

  （2）系统提供的堆只能弹出堆顶，做不到自由删除任何一个堆中的元素，或者说无法在时间复杂度O(N*logN)内完成，一定会高于！

  根本原因：java中无反向索引表，C++里可能有。(堆只是一个数组！)

```java
public class Inner<T>{//Inner类只有自己可见
    public T value;
    public Inner(T v){
        value=v;
    }
}//定义一个内部类，当外部元素进来时，每一个元素都会有其独立的内存地址
public class HeapGreater<T> { //加强堆，泛型T，T一定要是非基础类型，有基础类型需求要包一层Inner
	private ArrayList<Inner<T>> heap; //堆结构（动态数组arraylist）
	private HashMap<Inner<T>, Integer> indexMap; //反向索引表,某一个对象进来放在了堆的什么位置，哈希表对两个相同的整型会覆盖掉!
	private int heapSize; //堆大小
	private Comparator<? super T> comp; //比大小的比较器

	public HeapGreater(Comparator<T> c) {
		heap = new ArrayList<>();
		indexMap = new HashMap<>();
		heapSize = 0;
		comp = c;
	}
    public boolean isEmpty() {
		return heapSize == 0;
	} //看堆是不是空

	public int size() {
		return heapSize;
	}

	public boolean contains(T obj) {
		return indexMap.containsKey(obj);
	}//考察堆中有无这个元素，用反向索引表：O(1)

	public T peek() {
		return heap.get(0);
	}//看一下堆顶元素是啥

	public void push(T obj) {
		heap.add(obj); //在堆里加到最后
		indexMap.put(obj, heapSize); //把自己的位置记到反向索引表中
		heapInsert(heapSize++);//加入后往上移动
	}//加入堆
    
    public T pop() {
		T ans = heap.get(0);
		swap(0, heapSize - 1); //把最后位置的数和0位置的数做交换
		indexMap.remove(ans); //在反向索引表把最后那个数的下标删掉
		heap.remove(--heapSize); //堆大小 -1
		heapify(0); //从0开始往下做堆调整
        return ans;
    }
    
    public void remove(T obj) {//高效的删掉某个元素，系统只能删掉堆顶
    //方法：先根据反向索引表找到要删掉的元素的位置，再用最后一个元素的值替换它，再删掉最后一个元素，再heapinsert或heapify
		T replace = heap.get(heapSize - 1);
		int index = indexMap.get(obj);
		indexMap.remove(obj);
		heap.remove(--heapSize);
		if (obj != replace) {//如果删的就是最后一个元素，不用做任何调整
			heap.set(index, replace);
			indexMap.put(replace, index);
			resign(replace);
		}
	}//O(logN)

	public void resign(T obj) {//给你一个对象，告诉你其内部值发生变化，把整个堆继续调有序
		heapInsert(indexMap.get(obj));//先拿到他的位置，再heapinsert或heapify，只会发生一个！
		heapify(indexMap.get(obj));
	} //logN
    
    // 请返回堆上的所有元素
	public List<T> getAllElements() {
		List<T> ans = new ArrayList<>();
		for (T c : heap) {
			ans.add(c);
		}
		return ans;
	}
    
    private void heapInsert(int index) {
		while (comp.compare(heap.get(index), heap.get((index - 1) / 2)) < 0) {
			swap(index, (index - 1) / 2);
			index = (index - 1) / 2;
		}
	} 

	private void heapify(int index) {
		int left = index * 2 + 1;
		while (left < heapSize) {
			int best = left + 1 < heapSize && comp.compare(heap.get(left + 1), heap.get(left)) < 0 ? (left + 1) : left;
			best = comp.compare(heap.get(best), heap.get(index)) < 0 ? best : index; //调用比较器来调整
			if (best == index) {
				break;
			}
			swap(best, index);
			index = best;
			left = index * 2 + 1;
		}
	}
    
    private void swap(int i, int j) {
		T o1 = heap.get(i);
		T o2 = heap.get(j);
		heap.set(i, o2);
		heap.set(j, o1);
		indexMap.put(o2, i);
		indexMap.put(o1, j);//反向索引表一定要同步换！ 
	}//把元素在堆上的位置交换

}
```

练习：

给定一个整形数组int arr 和一个布尔类型数组boolean[] op，两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作

arr=[3,3,1,2,1,2,5……]

op =[T,T,T,T,F,T,F……]

依次表示：3用户购买了1件商品，1用户购买了1见商品，2用户购买了1件商品，1用户退货了1件商品……

一对arr[i]和op[i]就代表一个事件，现在你想在每一个事件到来的时候都给购买次数最多的前K名用户颁奖。所以每个事情发生后需要一个候选区(大小不限)和得奖区(大小为2)，（5，1，0）表示0号时间点5号用户买了一件商品。

规则：

1. 如果某个用户购买商品数为0，但是又发生了退货事件，则认为该事件无效，得奖名单和之前事件时一致，比如例子中的5用户。

2. 某用户发生购买商品事件，购买商品数+1，退货事件购买商品数-1

3. 每次都是最多k个用户得奖，k也为传入的参数，如果得奖人数不够K个，那就以不够的情况输出结果

4. 得奖系统分为得奖区和候选区，任何用户只要购买数＞0，一定在二者中一个

5. 购买数最大的前k名用户进入得奖区，在最初时若得奖区没有达到k个，那么新来的用户直接进入得奖区

6. 如果购买人数不足以进入得奖区的用户，进入候选区

7. 如果候选区购买数最多的用户，已经足以进入得奖区，该用户就会替换得奖区购买数最少的用户(＞才能替换)；如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户；如果得奖区中购买数最多的用户有多个，机会会给最早进入候选区的用户

8. 候选区和得奖区是两套时间。

   因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有从得奖区出来进入候选区的用户，得奖区时间删除。

   进入候选区的时间就是当前事件的时间，从候选区出来进入得奖区的用户，候选时间删除。

   进入得奖区的时间就是当前事件的事件，可理解为arr[i]和op[i]中的i

9. 如果某用户购买数 == 0，不管在哪个区域都离开，区域时间删除，离开是指彻底离开，哪个区域也不会找到该用户，如果下次该用户又发生购买行为产生＞0的购买数，会根据之前规则回到某个区域总，进入区域的时间重记。

```java
   public static List<List<Integer>> topK(int[] arr, boolean[] op, int k) {
		List<List<Integer>> ans = new ArrayList<>();
		WhosYourDaddy whoDaddies = new WhosYourDaddy(k);
		for (int i = 0; i < arr.length; i++) {
			whoDaddies.operate(i, arr[i], op[i]);
			ans.add(whoDaddies.getDaddies());
		}
		return ans;
	} //主函数
```

```java
   public static class WhosYourDaddy {
		private HashMap<Integer, Customer> customers;//id与customer对应表
		private HeapGreater<Customer> candHeap;//候选加强堆
		private HeapGreater<Customer> daddyHeap;//得奖加强堆
		private final int daddyLimit; 

		public WhosYourDaddy(int limit) {
			customers = new HashMap<Integer, Customer>();
			candHeap = new HeapGreater<>(new CandidateComparator());//大根堆
			daddyHeap = new HeapGreater<>(new DaddyComparator());//小根堆
			daddyLimit = limit;
		}
    
    // 当前处理i号事件，arr[i] -> id,  buyOrRefund
		public void operate(int time, int id, boolean buyOrRefund) {
			if (!buyOrRefund && !customers.containsKey(id)) {
				return;
			}//如果退货且两个区域都没你，等同于没发生
			if (!customers.containsKey(id)) {
				customers.put(id, new Customer(id, 0, 0));
			}
			Customer c = customers.get(id);
			if (buyOrRefund) {
				c.buy++;//用户购买则数量+1
			} else {
				c.buy--;
			}
			if (c.buy == 0) {
				customers.remove(id);
			} //购买数为0，在customer中把它删掉 ，都是O(1)
			if (!candHeap.contains(c) && !daddyHeap.contains(c)) {//得奖区和候选区都没有
				if (daddyHeap.size() < daddyLimit) {//得奖区数量不够
					c.enterTime = time;
					daddyHeap.push(c); //设置时间加进来，O(logN)
				} else {
					c.enterTime = time;
					candHeap.push(c); //否则进入候选区中待命，O(logN)
				}
			} else if (candHeap.contains(c)) {//在两个区中的一个，当前在候选区
				if (c.buy == 0) {
					candHeap.remove(c); //此时购买数为0，删掉它，此处很高效 O(LOGn)
				} else {
					candHeap.resign(c); //否则调整堆，维持堆的样子
				}
			} else { //在得奖区
				if (c.buy == 0) {
					daddyHeap.remove(c);
				} else {
					daddyHeap.resign(c);
				}
			}
			daddyMove(time); //看看爹移不移动
		}
    
        public List<Integer> getDaddies() {
			List<Customer> customers = daddyHeap.getAllElements(); //加强堆定义的返回所有函数功能
			List<Integer> ans = new ArrayList<>();
			for (Customer c : customers) {
				ans.add(c.id);
			}
			return ans;
		}
       
        private void daddyMove(int time) { //移动爹
			if (candHeap.isEmpty()) {
				return;
			} //候选区为空啥也不干
			if (daddyHeap.size() < daddyLimit) { //得奖区数量不够
				Customer p = candHeap.pop(); //候选区弹出一个进去
				p.enterTime = time; //时间重置
				daddyHeap.push(p);
			} else { //得奖区数量满了
				if (candHeap.peek().buy > daddyHeap.peek().buy) {//能够替换
					Customer oldDaddy = daddyHeap.pop(); //得奖区弹出对象
					Customer newDaddy = candHeap.pop(); //候选区弹出对象
					oldDaddy.enterTime = time;
					newDaddy.enterTime = time; //分别重置时间为其弹出来的时间
					daddyHeap.push(newDaddy);
					candHeap.push(oldDaddy);
				}
			}
		}
	}//得奖区(大小为K)总代价：O(N*logK) 候选区：O(N*logN) 拉出来成为一个链 O(N*K)
```

### 前缀树

1. 单个字符串中，字符从前到后的加到一颗多叉树上

2. 字符放在路上，节点上有专属的数据项（常见的是pass和end值）p：在加字符串时，有多少个字符串到达过这个节点。e：当前节点有多少字符串以它结尾

3. 所有样本都这样参加，如果没有路就新建，如有路就复用

4. 沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1 

   可以完成前缀的查询

![image-20211209194129646](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211209194129646.png)

寻找一个字符出现了几次：直接看e的值

查看所有字符串以bc做前缀：查看p的值

哈希表忽略掉单样本大小的情况下是O(1)，考虑样本大小长度k不可忽略，那么是O(k)，这是因为要遍历每个字符才能算出哈希值，如果是对象地址（非基础类型就拿内存地址计算哈希值）就是O(1)。

在性能方面，前缀树和哈希表一样，但是能实现计算前缀个数的功能

```java
// 前缀树节点类型
public static class Node1 {
   public int pass;
   public int end;
   public Node1[] nexts;
   //char tmp = ‘b' (tmp-'a')=1→找1路
   public Node1() {
      pass = 0;
      end = 0;
      //下标0 认为是走向a的路;
      //1    b;
      //2    c;
      //25   z;
      //next[i] == null i方向的路不存在
      //next[i] != null i方向的路存在
      nexts = new Node1[26];
   }
}
```

```java
public void insert(String word) { //加入字符
   if (word == null) {
      return;
   }
   char[] chs = word.toCharArray(); 把'abc'拆成['a','b','c']的数组形式
   Node1 node = root;
   node.pass++;
   int index = 0;
   for (int i = 0; i < chs.length; i++) { // 从左往右遍历字符
      index = chs[i] - 'a'; // 由字符，对应成走向哪条路
      if (node.nexts[index] == null) {//当前节点往下0、1、2的路是否为空
         node.nexts[index] = new Node1(); //为空则建立节点
      }
      node = node.nexts[pass];
      node.pass++;
   }
   node.end++;
}

数据类型很多时，用哈希表。
		private HashMap<String, Integer> box;

		public Right() {
			box = new HashMap<>();
		}

```

```java
public void delete(String word) { //删除字符：不要内存泄漏！如果节点p=e=0，则删除节点
   if (search(word) != 0) {
      char[] chs = word.toCharArray();
      Node2 node = root;
      node.pass--;
      int index = 0;
      for (int i = 0; i < chs.length; i++) {
         index = (int) chs[i];
         if (--node.nexts.get(index).pass == 0) {
            node.nexts.remove(index); //把底层塞空，释放节点，
            return;
         }
         node = node.nexts.get(index);
      }
      node.end--;
   }
}
```

### 不基于比较的排序：

基于比较的排序：冒泡、快排、归并等等

- 计数排序：（桶排序）利用容器的思想，桶的顺序就是数据的顺序（一定要数据比较特殊）


eg：假如排序很多人的年龄，那么需要准备一个辅助数组，第i位的数组统计年龄为i的人数，那么顺序打印此辅助数组即可完成排序，复杂度O(N)+O(N)

- 基数排序：数据范围限制：非负的，能表达成十进制的数字

  103，013，027，025，017，009

  流程：准备一些桶，按个位数：把个位数为i的数按顺序放到i号桶里，再从0号桶往外倒数字，先进的先出，

  103，013，025，027，017，009（根据各位数字排序）

  所有数字根据十位数字进桶，重复上面的流程

  103，009，013，017，025，027

  所有数字根据百位数字进桶，重复上面的流程

  009，013，017，025，027，103
  
  但是这样要准备很多桶，很浪费空间，采用一种巧妙方法，只需要两个数组即可实现入桶出桶

```java
public static void radixSort(int[] arr, int L, int R, int digit) {
   final int radix = 10;
   int i = 0, j = 0;
   // 有多少个数准备多少个辅助空间
   int[] help = new int[R - L + 1];
   for (int d = 1; d <= digit; d++) { // 有多少位就进出几次
      // 10个空间
       // count[0] 当前位(d位)是0的数字有多少个
      // count[1] 当前位(d位)是(0和1)的数字有多少个，即当前位小于等于i的有多少个
      // count[2] 当前位(d位)是(0、1和2)的数字有多少个
      // count[i] 当前位(d位)是(0~i)的数字有多少个
      int[] count = new int[radix]; // count[0..9] 准备长度为10的空间
      for (i = L; i <= R; i++) {
         // 103  1   3
         // 209  1   9
         j = getDigit(arr[i], d); //把每一个数在个十百位数字提取出来（第一次是个位）
         count[j]++; //统计每个个位数字出现的次数
      }
      for (i = 1; i < radix; i++) {
         count[i] = count[i] + count[i - 1];
      } //把count转换为count',即第i位存放 小于等于 个位数为i的数字个数
      for (i = R; i >= L; i--) { //从右往左遍历
         j = getDigit(arr[i], d); //当前数字在这一位（个十百）上的数字提取出来
         help[count[j] - 1] = arr[i]; // 把这一位的数放到辅助数组里，比如：011，034，021，012，031，001，第一个数为001，那么应放到help[3]的位置（count[j]=4，有四个数个位数为1），然后count[j]--。
         count[j]--; //让你自己这一位的词频-1
      } //出桶
      for (i = L, j = 0; i <= R; i++, j++) {
         arr[i] = help[j];//把help数组拷贝到arr里，准备下一轮。
      }
   }
} //复杂度：O(N*log10(max))，每次N个数进桶出桶，一共log10(max)次
```

#### 排序算法总结

排序算法的稳定性：

- 稳定性是指同样大小的样本再排序之后不会改变相对次序

- 对基础类型来说，稳定性毫无意义，因为基础类型的值是唯一意义

- 对非基础类型来说，稳定性有重要意义

- 有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的

- O(N2):选择排序（0~N-1选一个最小值放在0位置，交换数的时候没有稳定性）无稳定性；

  冒泡（整个范围内相邻数谁大谁往右，相等的时候不让他们换）、插入排序（之前以及排好了序列，新来的数字发现自己小就往前交换，相等的时候不让其往前交换）可以有稳定性

- O(NlogN):快速排序（partition不能稳定）、堆排序（调成大根堆不稳定）无稳定性；

  归并排序能稳定（相等的时候先拷贝左组的数字）

![image-20211212164523829](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211212164523829.png)

排序算法总结

1. 不基于比较的排序，对样本数据有严格要求，不易改写
2. 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
3. 基于比较的排序，时间复杂度的**极限**是O(NlogN)
4. 时间复杂度O(NlogN)，额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的
5. 为了**绝对的速度**选快排（快排**常数时间**最小），为了**省空间**选堆排，为了**稳定性**选归并

常见的坑：

1. 归并排序的额外空间复杂度可以变成O(1)，使用”归并排序 内部缓存法“，但是将变得不稳定！！
2. ”原地归并排序“是垃圾帖，会让时间复杂度变成O(N^2)
3. 快速排序稳定性改进，”01 stable sort“论文， 但是会对样本数据要求更多
4. **这道题是个坑！无法实现！**在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始的相对次序不变，且时间复杂度O(N)，额外空间复杂度O(1)(不能申请辅助数组，只能用有限个变量完成)eg:[1,1,2,3,4,6,5]→[1,1,3,5,2,4,6]

工程上对排序的改进：

1. 稳定性的考虑

   如：Arrays.sort()函数，array里是基础类型，那么用改进的快排，如果是非基础类型，那么用归并排序（这是要保证稳定性）

2. 充分利用O(NlogN)和O(N^2)排序各自的优势

   eg: **在快速排序中：**

   if(L+60 > R){

   ​           执行插入排序arr[L..R]

   ​           return;

    } //**插入排序 O(N2)，常数项小；快排O(Nlogn) ，常数项大。那么当N很大，一定要快排，当N不大的时候，可能插入排序更好。**

### 链表问题

- **面对链表解题方法论：**

对于面试，不用太在乎空间复杂度，一切为了时间复杂度

对于面试，时间复杂度仍然放在第一位，但一定要找到空间最省的方法

问题：索引可能会指飞，边界问题！

- 链表面试题常用数据结构和技巧：

  使用容器(哈希表/数组等)；快慢指针

- 快慢指针：快指针一次走两步，慢指针一次走一步，当快指针走完时，慢指针正好走到近似中点位置
  1. 输入链表头结点，奇数长度返回中点，偶数长度返回上中点
  2. 输入链表头结点，奇数长度返回中点，偶数长度返回下中点
  3. 输入链表头结点，奇数长度返回中点前一个，偶数长度返回上中点前一个
  4. 输入链表头结点，奇数长度返回中点前一个，偶数长度返回下中点前一个

- 常见面试题：给定一个单链表的头结点head，判断该链表是否为回文结构（12321/1221这种对称结构）

  1. 使用栈：先入栈，然后每遍历一个数就出栈一个，判断正序和逆序是否相等。（笔试用）

     ```java
     	public static boolean isPalindrome1(Node head) {
     		Stack<Node> stack = new Stack<Node>();
     		Node cur = head;
     		while (cur != null) {//遍历链表，把每个数都压到栈里去
     			stack.push(cur);
     			cur = cur.next;
     		}
     		while (head != null) {
     			if (head.value != stack.pop().value) {//遍历链表，来一个弹出一个比对
     				return false;
     			}
     			head = head.next;
     		}
     		return true;
     	} //额外空间复杂度O(N)
     ```

  2. 使用快慢指针：先找到中点或上中点，然后反转中点右侧链表指向顺序，左引用指向头节点，右引用指向尾节点，比较是否相等，然后往next移动，如果左引用或右引用指向空，停止。再恢复链表原始样子，返回True/False。

     ```java
     	public static boolean isPalindrome3(Node head) {
     		if (head == null || head.next == null) {
     			return true;
     		}
     		Node n1 = head;
     		Node n2 = head;
     		while (n2.next != null && n2.next.next != null) { // find mid node
     			n1 = n1.next; // n1 -> mid,慢指针
     			n2 = n2.next.next; // n2 -> end，快指针
     		}
     		// n1 中点
     
     		n2 = n1.next; // n2 -> right part first node
     		n1.next = null; // mid.next -> null
     		Node n3 = null;
     		while (n2 != null) { // right part convert
     			n3 = n2.next; // n3 -> save next node
     			n2.next = n1; // next of right node convert
     			n1 = n2; // n1 move
     			n2 = n3; // n2 move
     		}
     		n3 = n1; // n3 -> save last node
     		n2 = head;// n2 -> left first node
     		boolean res = true;
     		while (n1 != null && n2 != null) { // check palindrome
     			if (n1.value != n2.value) {
     				res = false;
     				break;
     			}
     			n1 = n1.next; // left to mid
     			n2 = n2.next; // right to mid
     		}
     		n1 = n3.next;
     		n3.next = null;
     		while (n1 != null) { // recover list
     			n2 = n1.next;
     			n1.next = n3;
     			n3 = n1;
     			n1 = n2;
     		}
     		return res;
     	}//额外空间复杂度O(1)
     ```

  3. 新题：L1→L2→L3→L4→R1→R2→R3→R4 调整为 L1→R4→L2→R3→L3→R2→L4→R1：先找到中点或上中点，然后反转中点右侧链表指向顺序，左引用指向头节点，右引用指向尾节点，然后把他们俩连起来，在遍历下一组，再连起来

- 常见面试题：两个链表相加：给定两个链表的头结点head1和head2，认为从左到右是某个数字从低位到高位，返回相加之后的链表。

  例子：4→3→6      2→5→3   返回：6→8→9 （634+352=986）

  ```java
  public static ListNode addTwoNumbers(ListNode head1, ListNode head2) {
     int len1 = listLength(head1);
     int len2 = listLength(head2);
     ListNode l = len1 >= len2 ? head1 : head2;
     ListNode s = l == head1 ? head2 : head1;
     ListNode curL = l;
     ListNode curS = s;
     ListNode last = curL;  //last很重要！
     int carry = 0; //进位
     int curNum = 0;
     while (curS != null) {
        curNum = curL.val + curS.val + carry; //长链表信息＋短链表信息＋进位
        curL.val = (curNum % 10);
        carry = curNum / 10;
        last = curL;
        curL = curL.next;
        curS = curS.next;
     }
     while (curL != null) {
        curNum = curL.val + carry;
        curL.val = (curNum % 10);
        carry = curNum / 10;
        last = curL;
        curL = curL.next;
     }
     if (carry != 0) {
        last.next = new ListNode(1);//last作用：定位一下最后一个不为空的节点位置，因为之前的节点会被释放掉！
     }
     return l;
  }
  ```

- 两个有序链表的合并：给定两个有序链表的头结点head1和head2，返回合并后的大链表，要求依然有序。

  1→5→9；2→6→9

  ```java
  public static ListNode mergeTwoLists(ListNode head1, ListNode head2) {
     if (head1 == null || head2 == null) {
        return head1 == null ? head2 : head1;
     }//边界：判断是否为空
     ListNode head = head1.val <= head2.val ? head1 : head2;//头结点小的作为大链表头结点返回（指向1）
     ListNode cur1 = head.next;//cur1指向小头的结点，（指向5）
     ListNode cur2 = head == head1 ? head2 : head1; //cur2指向大头，（指向2）
     ListNode pre = head;//pre指向1
     while (cur1 != null && cur2 != null) {
        if (cur1.val <= cur2.val) {
           pre.next = cur1;
           cur1 = cur1.next;
        } else {
           pre.next = cur2;
           cur2 = cur2.next;
        }
        pre = pre.next;
     }
     pre.next = cur1 != null ? cur1 : cur2;//cur1，cur2谁不为空pernext指向谁
     return head;
  }//注意：head = pre表示head指向了pre指向的内存区域
  ```

- 常见面试题：将单链表按某值划分成左边小、中间相等、右边大的形式

  1. 把链表放入数组里，在数组上做partition (笔试用)

  2. 分成小中大三个部分，设置六个引用（开始都指向空）小头、小尾、等头、等尾、大头、大尾；遍历链表中每个元素，大于中间相等值的先令大头指向它，遍历到下一个大于的时候，令上个大头next指向它，大尾移动到这个元素，依次类推，再把各个部分之间串起来：小尾next连等头，等尾next连大头（面试用）

     ```java
     public static Node listPartition2(Node head, int pivot) {
     		Node sH = null; // small head
     		Node sT = null; // small tail
     		Node eH = null; // equal head
     		Node eT = null; // equal tail
     		Node mH = null; // big head
     		Node mT = null; // big tail
     		Node next = null; // save next node
     		// every node distributed to three lists
     		while (head != null) {
     			next = head.next; //先记住下面的环境
     			head.next = null; //断开与后续结点的链接
     			if (head.value < pivot) { //小于划分值
     				if (sH == null) { //小于结点值为空：你是第一个小于的节点
     					sH = head;
     					sT = head; //头和尾都是你
     				} else {
     					sT.next = head; //否则老结点的尾巴next指针串上你
     					sT = head; //你变成尾巴
     				}
     			} else if (head.value == pivot) { //连接等于区域
     				if (eH == null) {
     					eH = head;
     					eT = head;
     				} else {
     					eT.next = head;
     					eT = head;
     				}
     			} else {  //连接大于区域
     				if (mH == null) {
     					mH = head;
     					mT = head;
     				} else {
     					mT.next = head;
     					mT = head;
     				}
     			}
     			head = next;//head移动到下一个环境
     		}
             //整体连接
     		// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头
     		if (sT != null) { // 如果有小于区域
     			sT.next = eH; //不管有没有等于区域，直接连等于区域的头
     			eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT
     		}
     		// 下一步，一定是需要用eT 去接 大于区域的头
     		// 有等于区域，eT -> 等于区域的尾结点
     		// 无等于区域，eT -> 小于区域的尾结点
     		// eT变成尽量不为空的尾巴节点
     		if (eT != null) { // 如果小于区域和等于区域，不是都没有
     			eT.next = mH; //等于区域的尾连大于区域的头
     		}
     		return sH != null ? sH : (eH != null ? eH : mH);//小于区域不为空，小于区域头就是我整体头，小于区域为空：等于区域不为空：返回等于区域头结点，否则返回大于区域头结点
     	}
     ```

- 常见面试题：链表除了next指针还有random指针，每一个链表结点的random指针可能随机指向一个结点或null，拷贝此链表的结构。

  方法：建立哈希表，key代表原结点，value代表克隆节点，1结点通过哈希表找到1‘，通过next指针找到2，然后2查找哈希表找到2'，再把1'next指向2'，对random指针也依此操作。

  ```java
  public static Node copyListWithRand1(Node head) {
     // key 老节点
     // value 新节点
     HashMap<Node, Node> map = new HashMap<Node, Node>();//建立哈希表
     Node cur = head;
     while (cur != null) {
        map.put(cur, new Node(cur.value)); //建立新老节点对应关系
        cur = cur.next;
     }
     cur = head;
     while (cur != null) {
        // cur 老
        // map.get(cur) 新
        // 新.next ->  cur.next、random结点的克隆节点(hash表里找到)
        map.get(cur).next = map.get(cur.next);
        map.get(cur).rand = map.get(cur.rand);
        cur = cur.next;
     }
     return map.get(head);
  }
  ```

​       只用几个变量：把1'插在1和2之间，2’插在2和3之间，3‘插在3后，next指针设为null，从结构上构造一一对应（可以省去map）每次遍历一对，1通过自己的random指针找到3，3通过next指针找到3’，1通过next找到1‘，把1’random指针指向3‘即完成第一对的设置。然后完成每对的设置。最后把新链表分离开      

```java
public static Node copyListWithRand2(Node head) {
   if (head == null) {
      return null;
   }
   Node cur = head;
   Node next = null;
   // copy node and link to every node
   // 1 -> 2
   // 1 -> 1' -> 2
   while (cur != null) {
      // cur 挂在老 next 老的下一个
      next = cur.next;
      cur.next = new Node(cur.value);
      cur.next.next = next;
      cur = next;
   }
   cur = head;
   Node curCopy = null;
   // set copy node rand
   // 1 -> 1' -> 2 -> 2'
   while (cur != null) {
      // cur 老
      // cur.next 新 copy
      next = cur.next.next;
      curCopy = cur.next;
      curCopy.rand = cur.rand != null ? cur.rand.next : null;
      cur = next;
   }//不能边设置random指针边分离
   // head head.next
   Node res = head.next;
   cur = head;
   // split
   while (cur != null) {
      next = cur.next.next;
      curCopy = cur.next;
      cur.next = next;
      curCopy.next = next != null ? next.next : null;
      cur = next;
   }
   return res;
} //时间复杂度O(N)
```

- 常见面试题：给定两个可能有环也可能无环的单链表，头结点head1和head2.请实现一个函数，如果两个链表相交，请返回相交的第一个结点。如果不相交，请返回null。【要求】如果两个链表长度之和为N，时间复杂度达到O(N),额外空间复杂度达到O(1)

  *容器方法*：①先判断有没有环：使用hashset，每来到一个结点先查hashset里面有没有此节点，如果没有就把它放进去，如果有就说明他是第一个入环结点。②返回相交的结点：**情况1：head1、head2都无环**：做出一hashset，把第一个链表每个节点内存地址都放进set里，然后遍历第二个链表的每个节点，如果每个节点都不在hashset里，说明不相交。如果节点在set里，那么此节点即为交点。

  *不用容器方法*：

  ①先判断有没有环，如果有找到第一个入环结点：**准备一个快指针（一次跳2步），一个慢指针（一次跳1步）。如果两个指针相遇，那么把快指针回到开头，变成一次走一步，慢指针不变。那么他们一定会在入环结点处再次相遇。**
  
  ②返回相交的结点：
  
  **情况1：head1、head2都无环**：遍历两个链表到最后一个结点，如果他们的内存地址不相等**那么他们一定不相交**。因为如果相交，结点只会有一个next指针，末节点相同。假设两条链表长度分别为a，b(a>b)，让长的链表先走差值(a-b)步，然后短链表开始走，则它们一定会在第一个交点处相遇。
  
  **情况2：一个链表有环，另一个无环：**则他们不可能相交。
  
  **情况3：两个链表都有环：**a.各自独立成环，他们两个不相交(loop1≠loop2)。 b.head1与head2入环结点是一个(loop1=loop2)不看下面的环，只看上面的结构，与情况1相同。C.head1与head2入环结点是2个(loop1≠loop2)，（loop往下转一圈，能遇到loop2）
  
  ```java
  //找到链表第一个环节点，如果无环，返回null
  public static Node getLoopNode(Node head){
      if (head==null || head.next==null || head.next.next==null){
          return null;
      }
      //n1慢 n2快
      Node slow = head.next; //n1→slow
      Node fast = head.next.next; //n2→fast
      while (slow != fast){
          if(fast.next == null || fast.next.next == null){
              return null;
          }
          fast = fast.next.next;
          slow = slow.next;
      }
       //slow fast相遇
      fast = head;//n2从头部重新出发
      while (slow!=fast){
          slow=slow.next;
          fast=fast.next;
      }
      return slow;
  }
  //如果两个链表都无环，返回第一个相交结点，如果不相交，返回null
  public static Node noLoop(Node head1, Node head2){
      if (head1==null || head2==null){
          return null;
      }
      Node cur1=head1;
      Node cur2=head2;
      while(cur1.next != null){ //下一个节点不为空：继续
          n++;
          cur1 = cur1.next;
      } //cur1走到链表最后一个结点，
      while(cur2.next != null){
          n--;
          cur2 = cur2.next;
      } //如果n为正，链表1更长，n为负，链表2更长
      if (cur1 != cur2) {//如果内存地址不一样，那么说明没相交
          return null;
      }
      // n=链表1长度-链表2长度
      cur1 = n > 0 ? head1 : head2; //谁长，谁的头变成cur1
      cur2 = (cur1 == head1 ? head2 : head1); //谁短，谁的头变成cur2
      n = Maths.abs(n);
      while (n!=0){
          n--;
          cur1 = cur1.next;
      }
      while (cur1!=cur2){
          cur1 = cur1.next;
          cur2 = cur2.next;
      }
      return cur1;
  }
  //两个有环链表，返回第一个相交结点，如果不相交则返回null
  public static Node bothloop(Node head1,	Node loop1, Node head2, Node loop2){
      Node cur1=null;
      Node cur2=null;
      if(loop1 == loop2){ //情况b
          return noLoop(Node head1, Node head2);
      }
      else{
          cur1 = loop1.next;
          while (cur1 != loop1){
              if(cur1 == loop2){
                  return loop1; //情况c
              }
              cur1 = cur1.next;
          }
          return null; //情况1，不相交
      }
  }
  
  //主函数
  public static Node getIntersectNode (Node head1,Node head2){
      if (head1==null || head2==null){
          return null;
      }
      Node loop1 = getLoopNode(head1);
      Node loop2 = getLoopNode(head2);
      if (loop1 == null && loop2 == null){
          return noLoop(head1,head2);
      }
      if (loop1 == null && loop2 == null){
          return bothLoop(head1,head2);
      }
      return null;
  }
  ```

### 二叉树

- 二叉树结构描述：

  class node{V value; Node left; Node right;}

- 二叉树的先序中序后序遍历：

  先序：任何子树的处理顺序都是：先头结点、再左子树、然后右子树

  中序：任何子树的处理顺序都是：先左子树、再头结点、然后右子树

  后序：任何子树的处理顺序都是：先左子树、再右子树、然后头结点

  ```java
  //递归序实现：
  public static void pre(Node head){ 
      if (heal == null){
          return;
      }//第一次回
      System.out.println(head value); //先序
      pre(head.left);//第二次回
      pre(head.right);//第三次回
  }
  public static void pre(Node head){ 
      if (heal == null){
          return;
      }
      pos(head.left);
      pos(head.right);
      System.out.println(head value); //后序
  }
  
  public static void f(Node head){ 
      if (heal == null){ //第一次回到自己
          return;
      }
      f(head.left); //第二次回到自己
      f(head.right); //第三次回到自己
  }
  //递归序:递归函数先调f(a)，往下来到f(b)；然后来到f(d),然后往d的左边遍历遍历到空，然后向上第二次返回d，然后往d的右边遍历遍历到空，然后向上第三次返回d，d遍历完了，然后往上第二次回到b，然后b往游侠遍历到d，经过三次返回d后第二次返回b，此时b也遍历完了，第二次回到a，然后a来到c。最终每个结点都来到了3次
  //总顺序：abdddbeeebacfffcgggca。通过递归序加工出先序：第一次来到结点就打印，第二三次来到重复节点就不管：abdevfg 中序：把打印时机放到第二次。 后序：把打印时机放到第三次自己
  ```

  ![image-20220110103046466](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20220110103046466.png)

  ![image-20211215101548219](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20211215101548219.png)**附加题：证明：某一个结点，其先序遍历的前面所有节点和后续遍历的后面所有结点它们的交集是此节点的所有祖先节点** 。 所有的节点一共分成三类：x的所有祖先结点，x的子孩子，x作为左（右)树姿态的右（左)兄弟,①X所有的孩子结点：先序遍历中是先遍历X再遍历其孩子，其孩子会出现在X的后面，不会出现在X的交集中②在先序遍历时，X是左树姿态，它的右兄一定会出现在其之后，不会出现在先序遍历中X的左边及后序遍历中X的右边，只有X的祖先结点会出现在交集中

  ![image-20220110104344779](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20220110104344779.png)

- 非递归方式实现二叉树先序中序后序遍历

  前序遍历：①栈顶出来记为cur (这是为了继续遍历下面的子树）②有右压入右，有左压入左。先右再左，然后继续递归执行①②。每次弹出一个任务A，会拆成其左子任务和右子任务入栈，它们永远会比A的右任务早执行。这就是能保证先序遍历的原因。

  ```java
  public static void pre(Node head) { //前序遍历
     System.out.print("pre-order: ");
     if (head != null) {
        Stack<Node> stack = new Stack<Node>();
        stack.add(head); //头结点压栈
        while (!stack.isEmpty()) {
           head = stack.pop();
           System.out.print(head.value + " ");
           if (head.right != null) {
              stack.push(head.right);
           }
           if (head.left != null) {
              stack.push(head.left);
           }
        }
     }
     System.out.println();
  }  
  ```

```java
public static void pos1(Node head) {//后续遍历：即前序遍历改成头右左出栈，出栈时不打印，而是按序进入另一个栈，按序弹出这个栈的元素（左头右）即为后序遍历
   System.out.print("pos-order: ");
   if (head != null) {
      Stack<Node> s1 = new Stack<Node>();
      Stack<Node> s2 = new Stack<Node>();
      s1.push(head);
      while (!s1.isEmpty()) {
         head = s1.pop(); // 头 右 左
         s2.push(head); //压入另一个栈
         if (head.left != null) { //先压左
            s1.push(head.left);
         }
         if (head.right != null) { //后压右
            s1.push(head.right);
         }
      }
      // 左 右 头
      while (!s2.isEmpty()) {
         System.out.print(s2.pop().value + " ");
      }
   }
   System.out.println();
}
```

中序遍历：①当前节点cur，cur为头的树整条左边界进栈，直到遇到空。 ②从栈中弹出结点打印，（弹出顺序是由左到头）让次结点右孩子成为cur，转步骤①。③栈为空，停。

```java
public static void in(Node cur) {
   System.out.print("in-order: ");
   if (cur != null) {
      Stack<Node> stack = new Stack<Node>();
      while (!stack.isEmpty() || cur != null) { //栈和cur都为空时停止
         if (cur != null) {//把整条左边界压栈
            stack.push(cur);
            cur = cur.left;
         } else {
            cur = stack.pop();//弹出并打印
            System.out.print(cur.value + " ");
            cur = cur.right; //cur来到弹出节点右孩子位置
         }
      }
   }
   System.out.println();
}
//整棵树所有节点是可以由子树的左边界分解而成的
```

- 题目：只给你要删除的节点，不给头结点，把他删掉

  思路：把该节点的值用下一个结点的值代替，再删除下一个节点

  存在问题：若删除的结点是尾结点，则此方法无法做到，尾结点的next指向null，null是系统中一个单独的区域，一定要找到尾节点上一个结点把其next指向null（所以做不到）。这种方法在工程中不推荐！真正删除结点一定要找到其之前的结点！（比如某个结点绑定了一些服务，拷贝结点时这种绑定关系无法拷贝过去）

- 层序遍历：就是宽度优先遍历，用队列；可以通过设置flag变量的方式，来发现某一层的结束

  (1)进队列，队列弹出一个数，记为cur （2）有左孩子左孩子入队列，有右孩子入右队列。返回（1）循环执行

```java
public static void level(Node head) {
   if (head == null) {
      return;
   }
   Queue<Node> queue = new LinkedList<>();
   queue.add(head);//头结点入队列
   while (!queue.isEmpty()) {
      Node cur = queue.poll();//弹出
      System.out.println(cur.value);
      if (cur.left != null) { 
         queue.add(cur.left);//有左压左，有右压右
      }
      if (cur.right != null) {
         queue.add(cur.right);
      }
   }
}
```

- 二叉树的序列化和反序列化

  序列化：把二叉树转换成字符串，数和字符串是一一对应的

  - 先序序列化：null不要忽略！null用一个特殊字符代替。按先序的顺序把节点值及null保存到字符串里
  - 先序反序列化：

```java
//序列化
public static Queue<String> preSerial(Node head) {
   Queue<String> ans = new LinkedList<>();
   pres(head, ans);//递归函数
   return ans;
}//返回字符串队列

public static void pres(Node head, Queue<String> ans) {
	if (head == null) {
		ans.add(null);//规定空用“null”占位，
	} else {
		ans.add(String.valueOf(head.value));//把你的值转成字符串类型，加到字符串里
		pres(head.left, ans);//序列化左子树
		pres(head.right, ans);//序列化右子树
	}
}
```

```java
//反序列化
public static Node buildByPreQueue(Queue<String> prelist) {
   if (prelist == null || prelist.size() == 0) {
      return null; //给空树
   }
   return preb(prelist);
}

public static Node preb(Queue<String> prelist) {
   String value = prelist.poll();
   if (value == null) {//弹出字符发现是空。那么建立空结点
      return null;
   }
   Node head = new Node(Integer.valueOf(value));//不是空则转成整形然后把它作为此时头结点
   head.left = preb(prelist);
   head.right = preb(prelist);
   return head;
}
```

```java
/*
 * 二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化，
 * 以下代码全部实现了。
 * 但是，二叉树无法通过中序遍历的方式实现序列化和反序列化（有歧义）
 * 因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。
 * 比如如下两棵树
 *         __2
 *        /
 *       1
 *       和
 *       1__
 *          \
 *           2
 * 补足空位置的中序遍历结果都是{ null, 1, null, 2, null}
 *       
 * */
```

- 按层序列化

```java
public static Queue<String> levelSerial(Node head) {
   Queue<String> ans = new LinkedList<>();
   if (head == null) {
      ans.add(null);
   } else {
      ans.add(String.valueOf(head.value));//把头结点转成字符串放到队列里
      Queue<Node> queue = new LinkedList<Node>();//用node组成一个新队列
      queue.add(head);//头结点入新队列
      while (!queue.isEmpty()) {
         head = queue.poll(); // head 父   子
         if (head.left != null) {//左孩子不为空，既序列化又往队列里放
            ans.add(String.valueOf(head.left.value));
            queue.add(head.left);
         } else {
            ans.add(null);//左孩子为空：只序列化不往队列里放，往队列里放是为了支持按层遍历
         }
         if (head.right != null) {
            ans.add(String.valueOf(head.right.value));
            queue.add(head.right);
         } else {
            ans.add(null);
         }
      }
   }
   return ans;
}
```

```java
//按层反序列化
public static Node buildByLevelQueue(Queue<String> levelList) {
   if (levelList == null || levelList.size() == 0) {
      return null;
   }
   Node head = generateNode(levelList.poll());
   Queue<Node> queue = new LinkedList<Node>();//建立队列
   if (head != null) {//防止队列中只有一个null，不空进队列
      queue.add(head);
   }
   Node node = null;
   while (!queue.isEmpty()) {
      node = queue.poll();
      node.left = generateNode(levelList.poll());
      node.right = generateNode(levelList.poll());
      if (node.left != null) {
         queue.add(node.left);
      }
      if (node.right != null) {
         queue.add(node.right);
      }
   }
   return head;
}
	public static Node generateNode(String val) {//由一个字符串建出1个node
		if (val == null) {
			return null;
		}
		return new Node(Integer.valueOf(val));
	}
```

- 把多叉树转换成二叉树（力扣431）

  思路：把多叉树一个结点的所有孩子都放在其左子树的右边界上

  ![image-20220110165147426](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20220110165147426.png)

```
public static class Node {
   public int val;
   public List<Node> children;

   public Node() {
   }

   public Node(int _val) {
      val = _val;
   }

   public Node(int _val, List<Node> _children) {
      val = _val;
      children = _children;
   }
};
```

```java
public TreeNode encode(Node root) {
   if (root == null) {
      return null;
   }
   TreeNode head = new TreeNode(root.val);
   head.left = en(root.children);//所有孩子往左树右边界上挂
   return head;
}

private TreeNode en(List<Node> children) {
   TreeNode head = null;
   TreeNode cur = null;
   for (Node child : children) {//child:多叉树的节点
      TreeNode tNode = new TreeNode(child.val);//tnode：二叉树的节点
      if (head == null) {
         head = tNode;//如果是第一个，标记第一个
      } else {
         cur.right = tNode;//不是第一个，则挂在上一个的右孩子上
      }
      cur = tNode;
      cur.left = en(child.children);//当前child的子弄完之后回到for循环搞下一个子
   }
   return head;
}
```

```java
//反序列化
public Node decode(TreeNode root) {
   if (root == null) {
      return null;
   }
   return new Node(root.val, de(root.left));
}

public List<Node> de(TreeNode root) {//root：第一个孩子，要把兄弟们弄成一个列表返回给上游的父亲们
   List<Node> children = new ArrayList<>();
   while (root != null) {
      Node cur = new Node(root.val, de(root.left));//自己的孩子在左树右边界上，先把自己的孩子搞定(root.left)(Node:e/f)再和兄弟们会合
      children.add(cur);
      root = root.right;//root不断往右，相当于把兄弟们(b\c\d)加入child列表里去
   }
   return children;
}
```

- 如何设计一个打印整棵树的打印函数（福利函数）

- 求二叉树最宽的层有多少个结点（遍历当前层时要为下一层结点遍历到哪做准备）

  cur_end：遍历到当前层的最后一个结点

  next_end：开始遍历下一层的最后一个节点

```java
public static int maxWidthNoMap(Node head) {
   if (head == null) {
      return 0;
   }
   Queue<Node> queue = new LinkedList<>();
   queue.add(head);//开始把头结点入队列
   Node curEnd = head; // 当前层，最右节点是谁
   Node nextEnd = null; // 下一层，最右节点是谁
   int max = 0;
   int curLevelNodes = 0; // 当前层的节点数
   while (!queue.isEmpty()) {
      Node cur = queue.poll();//弹出一个结点标记为cur
      if (cur.left != null) {//统计本层结点，同时计算nextEnd
         queue.add(cur.left);
         nextEnd = cur.left;
      }
      if (cur.right != null) {
         queue.add(cur.right);
         nextEnd = cur.right;
      }
      curLevelNodes++;//每弹出一个结点，本层节点数++
      if (cur == curEnd) {
         max = Math.max(max, curLevelNodes);//max值和当前层结点数比大小
         curLevelNodes = 0;//层数统计清零
         curEnd = nextEnd;
      }
   }
   return max;
}
```

- 给你二叉树中的某个节点，返回该节点的后继节点。（二叉树结构里有父亲指针）（考察结构）

  后继节点定义：中序遍历（左头右）时某一个节点后面的节点叫做后继

  可否做到O(K)？K为某节点到其后继的距离

  ①X有右树：则后继为X右树的最左孩子

  ②X没右树：X依次往上依次查找父亲，若祖先是再上一层的右孩子继续遍历，直到找到某一层的节点，它是其祖先的左孩子，那么此祖先就是X的后继

  ③X是最后一个节点：X无后继
  
  ```java
  public static Node getSuccessorNode(Node node) {
     if (node == null) {
        return node;
     }
     if (node.right != null) {//有右子树
        return getLeftMost(node.right);
     } else { // 无右子树
        Node parent = node.parent;
        while (parent != null && parent.right == node) { // 当前节点是其父亲节点右孩子
           node = parent;
           parent = node.parent;
        }
        return parent;
     }
  }
  
  public static Node getLeftMost(Node node) {
     if (node == null) {
        return node;
     }
     while (node.left != null) {
        node = node.left;
     }
     return node;
  }
  ```

- 微软面试题：把一张纸条连续从下往上对折N次压出折痕后展开，按序打印折痕是凹的还是凸的。N=1：打印 down；N=2：打印 逗我呢down down up

  ![image-20220110213439454](C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20220110213439454.png)

  **每次对折，都会在上一次的新折痕的左右两端分别生成凹凸折痕，按序打印的结果就是这颗二叉树的中序遍历。**

  规则：①头结点凹 ②所有左子树凹③所有右子树凸

  ```java
  public static void printAllFolds(int N) {
     process(1, N, true);//头结点是凹
     System.out.println();
  }
  
  // 当前你来了一个节点，脑海中想象的！
  // 这个节点在第i层，一共有N层，N固定不变的
  // 这个节点如果是凹的话，down = True
  // 这个节点如果是凸的话，down = False
  // 函数的功能：中序打印以你想象的节点为头的整棵树！
  public static void process(int i, int N, boolean down) {
     if (i > N) {//想象节点大于层数，返回
        return;
     }
     process(i + 1, N, true);//想像下一层凹节点，直至超过层数返回
     System.out.print(down ? "凹 " : "凸 ");//打印节点类型
     process(i + 1, N, false);//想像下一层凸节点，
  }//节点数2^n-1，但额外空间数只有N
  ```

<img src="C:\Users\wzr\AppData\Roaming\Typora\typora-user-images\image-20220110213802510.png" alt="image-20220110213802510" style="zoom:50%;" />

#### 二叉树的递归套路

- 判断二叉树是否为完全二叉树（每一层要么是满的，如果不满也是最后一层不满，不满的层也是从左到右依次变满的）

  ①如果某棵树只有右孩子，直接返回false

  ②第一次遇到左右孩子不全时：接下来遍历的节点一定是叶子节点

  ③遍历完所有节点①②都满足，那么是完全二叉树

  ```java
  public static boolean isCBT1(Node head) {
     if (head == null) {
        return true;
     }//空树算完全二叉树
     LinkedList<Node> queue = new LinkedList<>();//二叉树遍历需要一个双端队列
     // 是否遇到过左右两个孩子不双全的节点
     boolean leaf = false;//初始设为false
     Node l = null;
     Node r = null;
     queue.add(head);
     while (!queue.isEmpty()) {
        head = queue.poll();
        l = head.left;
        r = head.right;
        if (
        // 如果遇到了不双全的节点之后，又发现当前节点不是叶节点
            (leaf && (l != null || r != null))//遇到过左右不双全的节点（leaf=true）且左右两个孩子节点有一个不是空（即此节点不是叶子节点） 
            || 
            (l == null && r != null)//有右无左
  
        ) {
           return false;
        }
        if (l != null) {
           queue.add(l);
        }
        if (r != null) {
           queue.add(r);//二叉树按层遍历
        }
        if (l == null || r == null) {//左右两个孩子只要有一个不为空，开关开启，开启后不会再变为false
           leaf = true;
        }
     }
     return true;
  }
  ```

- 给定一颗二叉树头结点，判断是否为平衡二叉树（**每一棵子树**的左树高度和右数高度之差不能超过1）

  判断违反的规则：左树不为平衡二叉树、右树不为平衡二叉树、绝对值之差大于1

  ```java
  public static boolean isBalanced2(Node head) {
     return process(head).isBalanced;
  }
  
  public static class Info{
     public boolean isBalanced;
     public int height;
     
     public Info(boolean i, int h) {
        isBalanced = i;
        height = h;
     }
  }//定义一个类，里面有是否是平衡树，树的高度，因为递归过程需要用高度差来判断
  
  public static Info process(Node x) {
     if(x == null) {
        return new Info(true, 0);
     }
     Info leftInfo = process(x.left);//递归自己，认为自己能要到左、右树的信息
     Info rightInfo = process(x.right);
     int height = Math.max(leftInfo.height, rightInfo.height)  + 1;//高度为左右子树高度最大值＋1，
     boolean isBalanced = true;
     if(!leftInfo.isBalanced) {
        isBalanced = false;
     }
     if(!rightInfo.isBalanced) {
        isBalanced = false;
     }
     if(Math.abs(leftInfo.height - rightInfo.height) > 1) {
        isBalanced = false;
     }//满足上述三种情况任意一种就不是平衡树
     return new Info(isBalanced, height);//返回两条信息才能连起来递归
  }
  ```

- 给定一颗二叉树头结点，判断是否为搜索二叉树（对每一棵子树的头结点：其左树上的值都比它小，其右树上的值都比它大）（经典搜索二叉树不含重复值！）

  判断方法1：中序遍历一下，看是否一直上升。

  判断方法2：列举可能性：

  ①X的左右子树分别是搜索二叉树   ②X左树最大值小于X   ③X右树最小值大于X

  对左树和对右树要求不一样（左数求最小，右树求最大）→求全集，即左、右树都求最大最小值以及是否为搜索二叉树（因为递归对所有节点一视同仁）→结构体里有三个信息

  ```java
  public static boolean isBST2(Node head) {
     if (head == null) {
        return true;
     }
     return process(head).isBST;
  }
  
  public static class Info {
     public boolean isBST;
     public int max;
     public int min;
  
     public Info(boolean i, int ma, int mi) {
        isBST = i;
        max = ma;
        min = mi;
     }
  
  }
  
  public static Info process(Node x) {
     if (x == null) {
        return null;
     } //不好设置空树的指标，先设为空，然后返回上游处理
     Info leftInfo = process(x.left);
     Info rightInfo = process(x.right);
     int max = x.value;
      
     //更新最大最小值
     if (leftInfo != null) {
        max = Math.max(max, leftInfo.max);
     }//左树不为空，那么最大值有可能因其变大
     if (rightInfo != null) {
        max = Math.max(max, rightInfo.max);
     }
     int min = x.value;
     if (leftInfo != null) {
        min = Math.min(min, leftInfo.min);
     }
     if (rightInfo != null) {
        min = Math.min(min, rightInfo.min);
     }
     
     //更新是否为搜索二叉树（2个条件）
     boolean isBST = true;
     if (leftInfo != null && !leftInfo.isBST) {
        isBST = false;
     }//左树不为空且违反了搜索二叉树
     if (rightInfo != null && !rightInfo.isBST) {
        isBST = false;
     }
     if (leftInfo != null && leftInfo.max >= x.value) {
        isBST = false;
     }
     if (rightInfo != null && rightInfo.min <= x.value) {
        isBST = false;
     }
     return new Info(isBST, max, min);//加工后返回三个信息递归
  }
  ```

- 给定一棵二叉树的头结点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离（一个节点走到另一个节点，中间节点只能走到一次，距离为整条路径上的节点数量）

  可能性：X整棵树的最大距离可能不通过X，

  路径不经过X：①X左树最大距离 ②X右树最大距离

  路径经过X：①X左树与X最远走到X右树离X最远（X左树、右树高度之和+1）

  **最后的最大距离是在以上三种可能中求最大**

  →要对左右树提的要求：最大距离、高度

  ```java
  public static int maxDistance2(Node head) {
     return process(head).maxDistance;
  }
  
  public static class Info {
     public int maxDistance;
     public int height;
  
     public Info(int m, int h) {
        maxDistance = m;
        height = h;
     }
  
  }
  
  public static Info process(Node x) {
     if (x == null) {
        return new Info(0, 0);
     }//空树最大距离和高度都为0
     Info leftInfo = process(x.left);
     Info rightInfo = process(x.right);
     int height = Math.max(leftInfo.height, rightInfo.height) + 1;
     int p1 = leftInfo.maxDistance;
     int p2 = rightInfo.maxDistance;
     int p3 = leftInfo.height + rightInfo.height + 1;
     int maxDistance = Math.max(Math.max(p1, p2), p3);//最大距离在三种可能求最大
     return new Info(maxDistance, height);
  }
  ```

- 判断一棵树是不是满二叉树（结点数为2^h-1）h为树的高度

  ```java
  public static boolean isFull2(Node head) {
     if (head == null) {
        return true;
     }
     Info all = process(head);
     return (1 << all.height) - 1 == all.nodes;
  }
  
  public static class Info {
     public int height;
     public int nodes;
  
     public Info(int h, int n) {
        height = h;
        nodes = n;
     }
  }
  
  public static Info process(Node head) {
     if (head == null) {
        return new Info(0, 0);
     }
     Info leftInfo = process(head.left);
     Info rightInfo = process(head.right);
     int height = Math.max(leftInfo.height, rightInfo.height) + 1;
     int nodes = leftInfo.nodes + rightInfo.nodes + 1;
     return new Info(height, nodes);
  }
  ```

- 找到某个子树是搜索二叉树，返回是搜索二叉树的子树的最大包含结点数

  X不做头：X左子树、右子树的搜索二叉树maxBSTsubtreesize取最大

  X做头：X整体是搜索二叉树。需要满足：①左、右树分别是BST②左树max＜X；右树min＞X③需要知道左右树的size（最后结果是二者size之和+1）

  需要信息：maxBSTsubtreesize；allsize；max；min。如果前两个值相等，说明是搜索二叉树！否则不是（这样可以省掉一个是否为搜索二叉树的信息）

  ```java
  public static int maxSubBSTSize2(Node head) {
     if(head == null) {
        return 0;
     }
     return process(head).maxBSTSubtreeSize;
  }
  
  public static class Info {
     public int maxBSTSubtreeSize;
     public int allSize;
     public int max;
     public int min;
  
     public Info(int m, int a, int ma, int mi) {
        maxBSTSubtreeSize = m;
        allSize = a;
        max = ma;
        min = mi;
     }
  }
  
  public static Info process(Node x) {
     if (x == null) {
        return null;
     }
     Info leftInfo = process(x.left);
     Info rightInfo = process(x.right);
     int max = x.value;
     int min = x.value;
     int allSize = 1;//初始值设置
      
      //更新参数
     if (leftInfo != null) {//左树不为空
        max = Math.max(leftInfo.max, max);//用左树最大最小值和max、min比较
        min = Math.min(leftInfo.min, min);
        allSize += leftInfo.allSize;
     }
     if (rightInfo != null) {
        max = Math.max(rightInfo.max, max);
        min = Math.min(rightInfo.min, min);
        allSize += rightInfo.allSize;
     }
      
     int p1 = -1;//可能性1（左子树最大搜索树size）=-1
     if (leftInfo != null) {//左边信息不为空，让P1重新赋一个正常的值
        p1 = leftInfo.maxBSTSubtreeSize;
     }
     int p2 = -1;//可能性2（右子树最大搜索树size）=-1
     if (rightInfo != null) {
        p2 = rightInfo.maxBSTSubtreeSize;
     }
     int p3 = -1;//可能性3（以X为头整体都为BST）
     boolean leftBST = leftInfo == null ? true : (leftInfo.maxBSTSubtreeSize == leftInfo.allSize);
      //如果为空树，那么是BST；如果不是空树，最大搜索二叉子树size＝其本身size，那么才是BST
     boolean rightBST = rightInfo == null ? true : (rightInfo.maxBSTSubtreeSize == rightInfo.allSize);
     if (leftBST && rightBST) {//左右两端都是搜索二叉树
        boolean leftMaxLessX = leftInfo == null ? true : (leftInfo.max < x.value);//左树为空，那么认为是true，不会改变性质；左树不为空，比较一下左树最大值与X的值
        boolean rightMinMoreX = rightInfo == null ? true : (x.value < rightInfo.min);
        if (leftMaxLessX && rightMinMoreX) {//上述两条件同时成立
           int leftSize = leftInfo == null ? 0 : leftInfo.allSize;//不要忘记判断是否为空
           int rightSize = rightInfo == null ? 0 : rightInfo.allSize;
           p3 = leftSize + rightSize + 1;
        }
     }
     return new Info(Math.max(p1, Math.max(p2, p3)), allSize, max, min);
  }//空树默认是搜索二叉树
  ```

- 上述方法所有复杂度都是O(N)，树形动态规划。

  可以解决面试中绝大多数二叉树问题尤其是树形dp问题

  本质是利用递归遍历二叉树的便利性

  步骤：

  ①加上以X节点为头，假设可以向X左树和X右树要任何信息

  **②在上一步的假设下，讨论以X为头结点的树，得到答案的可能性（最重要）**

  ③列出所有可能性，确定到底需要向左树和右树要什么信息

  ④把左树信息和右树信息求全集，就是任何一颗子树都需要返回的信息S

  ⑤递归函数都返回S，每一棵子树都这么要求

  ⑥写代码，在代码中考虑如何把左树、右树信息整合出整棵树的信息

- 判断二叉树是否是完全二叉树（用递归套路解）

  列举可能性：

  ①最后一层节点全是满的，左高等于右高

  ②最后一层节点不满，且从左到右依次变满

  左树是完全二叉树，左树不满，右树是满的，且左树高度比右树大一（最后一层节点没超过中线）

  左树是满的，右树是满的，且左树高度比右树大一（最后一层节点刚到中线，但没到右边）

  左树是满的，右树是完全二叉树，右树不满，且左树高度等于右树（最后一层节点超过中线）

  需要信息：是否满、树的高度，是否完全？

  ```java
  public static boolean isCBT2(Node head) {
     return process(head).isCBT;
  }
  
  public static class Info {
     public boolean isFull;
     public boolean isCBT;
     public int height;
  
     public Info(boolean full, boolean cbt, int h) {
        isFull = full;
        isCBT = cbt;
        height = h;
     }
  }
  
  public static Info process(Node x) {
     if (x == null) {
        return new Info(true, true, 0);
     }
     Info leftInfo = process(x.left);
     Info rightInfo = process(x.right);
     int height = Math.max(leftInfo.height, rightInfo.height) + 1;//高度
     boolean isFull = leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height;//左树、右树满且左右高度一样→是满的
     boolean isCBT = false;
     if (leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height) {//左树满右树满，高度一样
        isCBT = true;
     } else if (leftInfo.isCBT && rightInfo.isFull && leftInfo.height == rightInfo.height + 1) {//
        isCBT = true;
     } else if (leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height + 1) {
        isCBT = true;
     } else if (leftInfo.isFull && rightInfo.isCBT && leftInfo.height == rightInfo.height) {
        isCBT = true;
     }
     return new Info(isFull, isCBT, height);
  }
  ```

- 给定一棵二叉树的头结点head，返回这颗二叉树中最大的二叉搜索子树的头节点

- 给定一颗二叉树的头结点head，和另外两个节点a、b，返回此2个节点的最低公共祖先（此2个节点在哪最初汇聚）

  法1：把a及其沿途所有节点都加到一个hashset里，从B往上跳的时候，只要某一个节点在hashset里，那么此点就是最低公共祖先。

  ```java
  public static Node lowestAncestor1(Node head, Node o1, Node o2) {
     if (head == null) {
        return null;
     }
     // key的父节点是value
     HashMap<Node, Node> parentMap = new HashMap<>();
     parentMap.put(head, null);
     fillParentMap(head, parentMap);
     HashSet<Node> o1Set = new HashSet<>();
     Node cur = o1;
     o1Set.add(cur);
     while (parentMap.get(cur) != null) {
        cur = parentMap.get(cur);
        o1Set.add(cur);
     }
     cur = o2;
     while (!o1Set.contains(cur)) {
        cur = parentMap.get(cur);
     }
     return cur;
  }
  ```

  法2：二叉树的递归套路（利用后序遍历）

  汇聚点和X无关：（X不是最低汇聚点——答案）

  ①左树上有答案 ②右树有答案 ③以X为头整棵树a，b不全部含有

  X是答案：

  ①左树发现一个节点，右树发现另一个节点 ②X本身是a，左右树中有b ③X本身是b，其左右树上有a

  需要提供的信息：发没发现A，发没发现B，发没发现答案

  ```java
  public static Node lowestAncestor2(Node head, Node a, Node b) {
     return process(head, a, b).ans;
  }
  
  public static class Info {
     public boolean findA;
     public boolean findB;
     public Node ans;
  
     public Info(boolean fA, boolean fB, Node an) {
        findA = fA;
        findB = fB;
        ans = an;
     }
  }
  
  public static Info process(Node x, Node a, Node b) {
     if (x == null) {
        return new Info(false, false, null);
     }
     Info leftInfo = process(x.left, a, b);
     Info rightInfo = process(x.right, a, b);
     boolean findA = (x == a) || leftInfo.findA || rightInfo.findA;//x自己=a，左树有a，或者右树有b，这三种算是找到了a
     boolean findB = (x == b) || leftInfo.findB || rightInfo.findB;
     Node ans = null;
     if (leftInfo.ans != null) {//左树答案不为空
        ans = leftInfo.ans; //答案设置为左树找到的答案
     } else if (rightInfo.ans != null) {
        ans = rightInfo.ans;
     } else {//左右树都没答案
        if (findA && findB) {//既找到了a又找到了B，那么答案是他自己
           ans = x;
        }
     }
     return new Info(findA, findB, ans);
  }
  ```

- 一颗多叉树代表一个公司的层级结构，每一个节点会有一个happy值，可以选若干个节点参加聚会，选结点时不能选直接上下级；然后要求出参加聚会的happy值的最大累加和。

  ①在X来的时候最大快乐值是多少：x.happy+x各个孩子节点不来情况下的最大happy值

  ②X不来的时候最大快乐值是多少：X不来时，X子节点既可以来也可以不来→max{子节点1来maxhappy，子节点1不来maxhappy}+max{子节点2来maxhappy，子节点2不来maxhappy}

  →返回①②中最大的

  需要提供的信息：头结点来时maxhappy，头结点不来时maxhappy

  ```java
  public static class Employee {
     public int happy;
     public List<Employee> nexts;//所有子节点
  
     public Employee(int h) {
        happy = h;
        nexts = new ArrayList<>();
     }
  }
  ```

  ```java
  public static int maxHappy2(Employee head) {
  	Info allInfo = process(head);//最大的老板为头结点
  	return Math.max(allInfo.no, allInfo.yes);//返回最大老板来或不来时的最大收益
  }
  
  public static class Info {
     public int no;
     public int yes;
  
     public Info(int n, int y) {
        no = n;
        yes = y;
     }
  }
  
  public static Info process(Employee x) {
     if (x == null) {
        return new Info(0, 0);
     }
     int no = 0;
     int yes = x.happy;
     for (Employee next : x.nexts) {//遍历所有的后代
        Info nextInfo = process(next);//提供后代的信息
        no += Math.max(nextInfo.no, nextInfo.yes);//在不来时，后代又可以来又可以不来
        yes += nextInfo.no;//在来的情况下，只能获得在不来情况下的收益
     }
     return new Info(no, yes);
  }
  ```

### 贪心算法

-   贪心算法：

  ①最自然智慧的算法

  ②用一种局部最功利的标准，总是做出在当前看来是最好的选择

  ③难点在于证明局部最功利的标准可以得到全局最优解

  ④对于贪心算法的学习主要以增加阅历和经验为主

- 给定一个由字符串组成的数组strs，必须把所有的字符拼接起来，返回所有可能的拼接结果中，字典序最小的结果  

  字典序：

  ①字符串长度相等时，直接比数字大小

  ②字符串长度不等时：较短的字符串补最小的ascⅡ码补到长度相同（补0）

  证明：首先证明排序策略有传递性

  a.b≤b.a；b.c≤c.b →a.c≤c.a

  a.b→a拼接b=a*K^b长度+b，K^b长度=m(b)

  然后证明：一个字符串里：交换任意1个字符串必会导致字符串字典序上升→数学归纳法交换2个、3个、……N个

  （贪心在面试时考的概率不高）先用实验（对数器）的方式说明可行

  ```java
  public static class MyComparator implements Comparator<String> {
     @Override
     public int compare(String a, String b) {
        return (a + b).compareTo(b + a);//定义比较器，a+b小于等于b+a，a放前面
     }
  }
  
  public static String lowestString2(String[] strs) {
     if (strs == null || strs.length == 0) {
        return "";
     }
     Arrays.sort(strs, new MyComparator());//按比较器方法排序
     String res = "";
     for (int i = 0; i < strs.length; i++) {
        res += strs[i];
     }
     return res;
  }
  ```

- 一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间·和结束的时间。你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回最多的宣讲场次。

  方法1：贪心：选择结束时间最早的会议

  ```java
  	public static class Program {
  		public int start;
  		public int end;
  
  		public Program(int start, int end) {
  			this.start = start;
  			this.end = end;
  		}
  	}
  
  // 会议的开始时间和结束时间，都是数值，不会 < 0
  public static int bestArrange2(Program[] programs) {
     Arrays.sort(programs, new ProgramComparator());//调 用比较器
     int timeLine = 0;//结束时间
     int result = 0;
     // 依次遍历每一个会议，结束时间早的会议先遍历
     for (int i = 0; i < programs.length; i++) {
        if (timeLine <= programs[i].start) {//当前会议开始时间比当前时间晚
           result++;
           timeLine = programs[i].end;//时间点来到此会议结束的时刻
        }
     }
     return result;
  }
  
  public static class ProgramComparator implements Comparator<Program> {
  		@Override
  		public int compare(Program o1, Program o2) {
  			return o1.end - o2.end;
  		}
  	}//谁结束时间早排前面
  ```

​       方法2：暴力方法

```java
// 暴力！所有情况都尝试！
public static int bestArrange1(Program[] programs) {
   if (programs == null || programs.length == 0) {
      return 0;
   }
   return process(programs, 0, 0);//
}

// 还剩下的会议都放在programs里
// done之前已经安排了多少会议的数量
// timeLine目前来到的时间点是什么

// 目前来到timeLine的时间点，已经安排了done多的会议，剩下的会议programs可以自由安排
// 返回能安排的最多会议数量
public static int process(Program[] programs, int done, int timeLine) {
   if (programs.length == 0) {//剩下的会议没有了：返回done
      return done;
   }
   // 还剩下会议
   int max = done;
   // 当前安排的会议是什么会，每一个都枚举
   for (int i = 0; i < programs.length; i++) {
      if (programs[i].start >= timeLine) {//可以安排
         Program[] next = copyButExcept(programs, i);//把i位置的会议删掉，返回新数组
         max = Math.max(max, process(next, done + 1, programs[i].end));//看看后续安排了几个会，每一个可选择的会议都尝试一遍
      }
   }
   return max;
}

	public static Program[] copyButExcept(Program[] programs, int i) {
		Program[] ans = new Program[programs.length - 1];
		int index = 0;
		for (int k = 0; k < programs.length; k++) {
			if (k != i) {
				ans[index++] = programs[k];
			}
		}
		return ans;
	}
```

- 一块金条切成两半是需要花费和长度一样的铜板的，比如长度为20的金条不管怎么切都需要花费20个铜板，一群人想整分整块金条，怎么分最省铜板？

  例如：给定数组（10,20,30），代表一共三个人，整块金条长度为60，要分成10，20，30三个部分

  如果先把60的金条分成10和50，花费60；再把50分成20和20，花费50，一共花费110铜板

  但如果先把60长度分为30和30，花费60，再把30分成10和20，花费30，一共花费90铜板

  输入一个数组，返回分割的最小代价。

方法1：准备一个小根堆，把所有数字放进小根堆中，每次从小根堆弹出2个数，把这两个数加成一个数按照小根堆的顺序放回去，周而复始。当小根堆里只剩一个数时，即为最优分割方案。代价就是所有合成的数累加。（哈夫曼编码）

```java
public static int lessMoney2(int[] arr) {
   PriorityQueue<Integer> pQ = new PriorityQueue<>();//放整数的优先级队列：默认小根堆
   for (int i = 0; i < arr.length; i++) {
      pQ.add(arr[i]);
   }
   int sum = 0;//代价
   int cur = 0;
   while (pQ.size() > 1) {//小根堆里面有1个以上的数
      cur = pQ.poll() + pQ.poll();//弹出两个数相加
      sum += cur;
      pQ.add(cur);//把相加的数放进小根堆里
   }
   return sum;
}
```

方法2：暴力解

```java
public static int lessMoney1(int[] arr) {
	if (arr == null || arr.length == 0) {
		return 0;
	}
	return process(arr, 0);
}

// 等待合并的数都在arr里，pre：之前的合并行为产生了多少总代价
// arr中只剩一个数字的时候，停止合并，返回最小的总代价
public static int process(int[] arr, int pre) {
   if (arr.length == 1) {
      return pre;
   }
   int ans = Integer.MAX_VALUE;
   for (int i = 0; i < arr.length; i++) {//枚举所有两个数的组合
      for (int j = i + 1; j < arr.length; j++) {
         ans = Math.min(ans, process(copyAndMergeTwo(arr, i, j), pre + arr[i] + arr[j]));//递归
      }
   }
   return ans;
}

public static int[] copyAndMergeTwo(int[] arr, int i, int j) {
    //把arr中i和j位置的数合成一个新数组返回
   int[] ans = new int[arr.length - 1];
   int ansi = 0;
   for (int arri = 0; arri < arr.length; arri++) {
      if (arri != i && arri != j) {
         ans[ansi++] = arr[arri];
      }
   }
   ans[ansi] = arr[i] + arr[j];
   return ans;
}
```

- 输入：正数数组costs、正数数组profits，正数K、M

  cost[i]表示i号项目的花费

  profits[i]表示i号项目在扣除花费后还能挣到的钱（纯利润）

  K表示你只能串行的最多做K个项目

  M表示你初始的资金

  说明：每做完一个项目，马上获得的收益，可以支持你去做下一个项目，不能并行的做项目

  输出：你最后获得的最大钱数

方法：把所有项目按照花费进小根堆，按利润进大根堆，大根堆开始为空，首先把小根堆里所有能做的项目弹出来进大根堆，然后选择第一轮做大根堆的堆顶指代的项目，然后进入下一轮，继续此过程，看看新的钱能做小根堆里的哪些，能做的从小根堆弹出来到大根堆，一直到第K轮。

```java
// 最多K个项目
// W是初始资金
// Profits[] Capital[] 一定等长
// 返回最终最大的资金
public static int findMaximizedCapital(int K, int W, int[] Profits, int[] Capital) {
   PriorityQueue<Program> minCostQ = new PriorityQueue<>(new MinCostComparator());//谁花费小谁在小根堆堆顶
   PriorityQueue<Program> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());//谁利润高谁在大根堆堆顶
   for (int i = 0; i < Profits.length; i++) {
      minCostQ.add(new Program(Profits[i], Capital[i]));//建出每一个项目放进小根堆
   }
   for (int i = 0; i < K; i++) {//K轮做K个项目
      while (!minCostQ.isEmpty() && minCostQ.peek().c <= W) {
          //小根堆不为空且小根堆堆顶能做
         maxProfitQ.add(minCostQ.poll());//放到大根堆里
      }
      if (maxProfitQ.isEmpty()) {//做不到第K轮，需要提前结束
         return W;
      }
      W += maxProfitQ.poll().p;//提取大根堆堆顶里的资金
   }
   return W;
}
```

```java
    public static class Program {
      public int p;
      public int c;

      public Program(int p, int c) {
         this.p = p;
         this.c = c;
      }
   }

   public static class MinCostComparator implements Comparator<Program> {
      @Override
      public int compare(Program o1, Program o2) {
         return o1.c - o2.c;
      }
   }

   public static class MaxProfitComparator implements Comparator<Program> {
      @Override
      public int compare(Program o1, Program o2) {
         return o2.p - o1.p;
      }
   }
```

- （头条原题）给定一个字符串str，只有'X'和'.'两种字符组成，X表示墙，不能放灯，也不需要点亮，'.'表示居民点，可以放灯，需要点亮，如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮；返回如果点亮str中所有需要点亮的位置，至少需要几盏灯。

  解1：贪心

  ```java
  public static int minLight2(String road) {
     char[] str = road.toCharArray();
     int i = 0;
     int light = 0;
     while (i < str.length) {
        if (str[i] == 'X') {//不用放灯也无需照亮
           i++;
        } else {
           light++;
           if (i + 1 == str.length) {//走到了最后，没有位置
              break;
           } else { // 有i位置  i+ 1   X  .
              if (str[i + 1] == 'X') {
                 i = i + 2;
              } else {
                 i = i + 3;
              }
           }
        }
     }
     return light;
  }
  ```

### 并查集

每一个小样本在自己的集合里

（1）查询两个样本是否在一个集合里boolean issameset(a,e)；

（2）a所在的集合和e所在的集合合成一个void union(a,e)；

方法：选择代表节点。开始时代表节点的指针都指向他自己，然后合并时只需更改代表节点指针的指向即可。代表节点size小的挂到代表节点size大的上面。

```java
public static class Node<V> {
   V value;

   public Node(V v) {
      value = v;
   }
}

public static class UnionFind<V> {
   public HashMap<V, Node<V>> nodes;//把样本点包装一下，建立内部的对应关系，用户只认样本点。
   public HashMap<Node<V>, Node<V>> parents;//每一个节点有唯一的父亲，可以用指针来做，也可以用表来做key位置的父亲是value
   public HashMap<Node<V>, Integer> sizeMap;//只有一个节点是代表节点时才会在sizemap里记录

   public UnionFind(List<V> values) { 
      nodes = new HashMap<>();
      parents = new HashMap<>();
      sizeMap = new HashMap<>();
      for (V cur : values) {
         Node<V> node = new Node<>(cur);//生成新样本对应的包装
         nodes.put(cur, node);//让这个样本对应它相应的包装
         parents.put(node, node);//在自己的集合里指向自己
         sizeMap.put(node, 1);//每一个size都是1
      }
   }

   // 给你一个节点，请你往上到不能再往上，把代表节点返回
   public Node<V> findFather(Node<V> cur) {
      Stack<Node<V>> path = new Stack<>();//准备一个栈
      while (cur != parents.get(cur)) {//cur不是自己的父，说明没到顶
         path.push(cur);//沿途的节点加到路径里
         cur = parents.get(cur);//cur来到自己父的位置继续判断
      }
       //cur == perents.get(cur)
      while (!path.isEmpty()) {
         parents.put(path.pop(), cur);//栈中元素弹出，把他们的父亲改成cur
      }
      return cur;
   }

   public boolean isSameSet(V a, V b) {
      return findFather(nodes.get(a)) == findFather(nodes.get(b));
   }//如果a和b的代表节点是一个，那么a和b在同一个集合里

   public void union(V a, V b) {
      Node<V> aHead = findFather(nodes.get(a));
      Node<V> bHead = findFather(nodes.get(b));
       //如果a和b的代表节点相同，那么不用合并
      if (aHead != bHead) {
         int aSetSize = sizeMap.get(aHead);
         int bSetSize = sizeMap.get(bHead);
         Node<V> big = aSetSize >= bSetSize ? aHead : bHead;
         Node<V> small = ((big == aHead) ? bHead : aHead);//大小集合头部重定向
         parents.put(small, big);//小集合的头的指针指向大集合的头
         sizeMap.put(big, aSetSize + bSetSize);
         sizeMap.remove(small);//sizemap里只有代表节点
      }
   }

   public int sets() {
      return sizeMap.size();
   }

}
//让小挂大的原因：让链的长度增长较慢
//样本量N: findH() : O(N)，平均查找每个元素：O(1)
//并查集优点：单次查找每个元素O(1)→解决连通性问题
```

- （力扣547）给你一个n*n数组表示n个人之间的关系，(i,j)=0代表i和j不认识；1代表认识。M[i] [i]=1；若

m[i] [j]=1;则m[j] [i]=1。（互相认识）求整个关系里有多少圈子（连通区域）

```java
public static int findCircleNum(int[][] M) {
   int N = M.length;
   // {0} {1} {2} {N-1}
   UnionFind unionFind = new UnionFind(N);
   for (int i = 0; i < N; i++) {
      for (int j = i + 1; j < N; j++) {//只遍历右上半区
         if (M[i][j] == 1) { // i和j互相认识
            unionFind.union(i, j);//把i背后的集合和j背后的集合连成一个
         }
      }
   }
   return unionFind.sets();
}
```

```java
//用数组实现FInd
public static class UnionFind {
   // parent[i] = k ： i的父亲是k
   private int[] parent;
   // size[i] = k ： 如果i是代表节点，size[i]才有意义，否则无意义
   // i所在的集合大小是多少
   private int[] size;
   // 辅助结构（等价于原方法中的栈）
   private int[] help;
   // 一共有多少个集合
   private int sets;

   public UnionFind(int N) {
      parent = new int[N];
      size = new int[N];
      help = new int[N];
      sets = N;
      for (int i = 0; i < N; i++) {//初始化
         parent[i] = i;
         size[i] = 1;
      }
   }

   // 从i开始一直往上，往上到不能再往上，代表节点，返回
   // 这个过程要做路径压缩
   private int find(int i) {
      int hi = 0;
      while (i != parent[i]) {//还没找到代表节点
         help[hi++] = i;//沿途把所有位置都记下来
         i = parent[i];
      }
      for (hi--; hi >= 0; hi--) {
         parent[help[hi]] = i;//路径压缩：沿途所有节点的父亲都设置成i
      }
      return i;
   }

   public void union(int i, int j) {
      int f1 = find(i);//找i的父亲节点
      int f2 = find(j);
      if (f1 != f2) {
         if (size[f1] >= size[f2]) {
            size[f1] += size[f2];
            parent[f2] = f1;
         } else {
            size[f2] += size[f1];
            parent[f1] = f2;
         }
         sets--;
      }
   }

   public int sets() {
      return sets;
   }
}
```

- 岛问题：给定一个二维数组matrix，里面的值不是1就是0，上下左右相邻的1认为是一片岛，返回matrix中岛的数量

  法1：递归实现。思路：按每列从左往右依次遍历，值为1的调用感染函数，把其上下左右以及上下左右的上下左右为1的都改成2。

  ```java
  public static int numIslands3(char[][] board) {
     int islands = 0;
     for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
           if (board[i][j] == '1') {
              islands++;
              infect(board, i, j);
           }
        }
     }
     return islands;
  }//复杂度：m*n的矩阵：O(m*n)
  
  // 从(i,j)这个位置出发，把所有练成一片的'1'字符，变成2
  public static void infect(char[][] board, int i, int j) {
     if (i < 0 || i == board.length || j < 0 || j == board[0].length || board[i][j] != '1') {//越界或者当前位置不是1，直接返回
        return;
     }
     board[i][j] = 2;//是为了防止递归跑不完
     infect(board, i - 1, j);
     infect(board, i + 1, j);
     infect(board, i, j - 1);
     infect(board, i, j + 1);
  }
  ```

​       法2：并查集：

把每一个1认为是独立的集合。对每个1看左边和上面是否有1，如果有，合并。

```java
public static int numIslands1(char[][] board) {
   int row = board.length;
   int col = board[0].length;
   Dot[][] dots = new Dot[row][col];
   List<Dot> dotList = new ArrayList<>();
   for (int i = 0; i < row; i++) {
      for (int j = 0; j < col; j++) {
         if (board[i][j] == '1') {
            dots[i][j] = new Dot();
            dotList.add(dots[i][j]);
         }
      }
   }//新建一个空的dog类，并生成一个与原矩阵规模相同的dot矩阵，原矩阵位置为1的地方dot矩阵相应位置申请一块内存，原矩阵位置为0时dot矩阵相应位置地址为null
   UnionFind1<Dot> uf = new UnionFind1<>(dotList);
   for (int j = 1; j < col; j++) {//处理第0行
      // (0,j)  (0,0)跳过了（既无左也无上）  (0,1) (0,2) (0,3)
      if (board[0][j - 1] == '1' && board[0][j] == '1') {//自己是1左面是1，合并
         uf.union(dots[0][j - 1], dots[0][j]);//使用各自代表的dot合并
      }
   }
   for (int i = 1; i < row; i++) {//处理第0列
      if (board[i - 1][0] == '1' && board[i][0] == '1') {//自己是1且上面是1，合并
         uf.union(dots[i - 1][0], dots[i][0]);
      }
   }
   for (int i = 1; i < row; i++) {
      for (int j = 1; j < col; j++) {
         if (board[i][j] == '1') {
            if (board[i][j - 1] == '1') {
               uf.union(dots[i][j - 1], dots[i][j]);
            }
            if (board[i - 1][j] == '1') {
               uf.union(dots[i - 1][j], dots[i][j]);
            }
         }
      }
   }
   return uf.sets();
}

public static class Dot {

}

public static class Node<V> {

   V value;

   public Node(V v) {
      value = v;
   }

}
	public static class UnionFind1<V> {
		public HashMap<V, Node<V>> nodes;
		public HashMap<Node<V>, Node<V>> parents;
		public HashMap<Node<V>, Integer> sizeMap;

		public UnionFind1(List<V> values) {
			nodes = new HashMap<>();
			parents = new HashMap<>();
			sizeMap = new HashMap<>();
			for (V cur : values) {
				Node<V> node = new Node<>(cur);
				nodes.put(cur, node);
				parents.put(node, node);
				sizeMap.put(node, 1);
			}
		}

		public Node<V> findFather(Node<V> cur) {
			Stack<Node<V>> path = new Stack<>();
			while (cur != parents.get(cur)) {
				path.push(cur);
				cur = parents.get(cur);
			}
			while (!path.isEmpty()) {
				parents.put(path.pop(), cur);
			}
			return cur;
		}

		public void union(V a, V b) {
			Node<V> aHead = findFather(nodes.get(a));
			Node<V> bHead = findFather(nodes.get(b));
			if (aHead != bHead) {
				int aSetSize = sizeMap.get(aHead);
				int bSetSize = sizeMap.get(bHead);
				Node<V> big = aSetSize >= bSetSize ? aHead : bHead;
				Node<V> small = big == aHead ? bHead : aHead;
				parents.put(small, big);
				sizeMap.put(big, aSetSize + bSetSize);
				sizeMap.remove(small);
			}
		}

		public int sets() {
			return sizeMap.size();
		}

	}
```

法3：

```java
public static int numIslands2(char[][] board) {
   int row = board.length;
   int col = board[0].length;
   UnionFind2 uf = new UnionFind2(board);
   for (int j = 1; j < col; j++) {
      if (board[0][j - 1] == '1' && board[0][j] == '1') {
         uf.union(0, j - 1, 0, j);
      }
   }
   for (int i = 1; i < row; i++) {
      if (board[i - 1][0] == '1' && board[i][0] == '1') {
         uf.union(i - 1, 0, i, 0);
      }
   }
   for (int i = 1; i < row; i++) {
      for (int j = 1; j < col; j++) {
         if (board[i][j] == '1') {
            if (board[i][j - 1] == '1') {
               uf.union(i, j - 1, i, j);
            }
            if (board[i - 1][j] == '1') {
               uf.union(i - 1, j, i, j);
            }
         }
      }
   }
   return uf.sets();
}
```

```java
public static class UnionFind2 {
   private int[] parent;
   private int[] size;
   private int[] help;
   private int col;//列号
   private int sets;//集合大小

   public UnionFind2(char[][] board) {
      col = board[0].length;
      sets = 0;
      int row = board.length;
      int len = row * col;
      parent = new int[len];
      size = new int[len];
      help = new int[len];
      for (int r = 0; r < row; r++) {
         for (int c = 0; c < col; c++) {
            if (board[r][c] == '1') {//初始化：
               int i = index(r, c);
               parent[i] = i;
               size[i] = 1;
               sets++;
            }
         }
      }
   }

   // (r,c) -> i
   private int index(int r, int c) {
      return r * col + c;//换算r行c列的下标
   }

   // 原始位置 -> 下标
   private int find(int i) {
      int hi = 0;
      while (i != parent[i]) {
         help[hi++] = i;
         i = parent[i];
      }
      for (hi--; hi >= 0; hi--) {
         parent[help[hi]] = i;
      }
      return i;
   }

   public void union(int r1, int c1, int r2, int c2) {
      int i1 = index(r1, c1);
      int i2 = index(r2, c2);
      int f1 = find(i1);
      int f2 = find(i2);
      if (f1 != f2) {
         if (size[f1] >= size[f2]) {
            size[f1] += size[f2];
            parent[f2] = f1;
         } else {
            size[f2] += size[f1];
            parent[f1] = f2;
         }
         sets--;
      }
   }

   public int sets() {
      return sets;
   }

}
```

- 给你空降几个位置，要你给出每一步的岛数量（力扣305）

### 图

有向图、无向图

表示：邻接表法、邻接矩阵法  

拿到面试题，先转换为自己的图结构，然后实现算法

- 图的描述

```java
// 点结构的描述
public class Node {
   public int value;
   public int in;//入度：指向它的点的数量
   public int out;//出度：它指向其他点的数量
   public ArrayList<Node> nexts;//从它出发能找到哪些邻居
   public ArrayList<Edge> edges;//从它出发有哪些直接的边

   public Node(int value) {
      this.value = value;
      in = 0;
      out = 0;
      nexts = new ArrayList<>();
      edges = new ArrayList<>();
   }
}
```

```java
//边结构的描述
public class Edge {
   public int weight;//权重
   public Node from;//从哪来
   public Node to;//到哪去

   public Edge(int weight, Node from, Node to) {
      this.weight = weight;
      this.from = from;
      this.to = to;
   }

}
```

```java
//图的描述：所有的点集和边集就构成一个图
public class Graph {
   public HashMap<Integer, Node> nodes;
   public HashSet<Edge> edges;
   
   public Graph() {
      nodes = new HashMap<>();
      edges = new HashSet<>();
   }
}
```

- 生成图

```java
// matrix 所有的边
// N*3 的矩阵
// [weight, from节点上面的值，to节点上面的值]
// 
// [ 5 , 0 , 7]表示0指向7的权重为5
// [ 3 , 0,  1]
// 
public static Graph createGraph(int[][] matrix) {
   Graph graph = new Graph();
   for (int i = 0; i < matrix.length; i++) {
       // 拿到每一条边， matrix[i] 
      int weight = matrix[i][0];
      int from = matrix[i][1];
      int to = matrix[i][2];
      if (!graph.nodes.containsKey(from)) {//点集中没有from这个点：那么要建出来
         graph.nodes.put(from, new Node(from));
      }
      if (!graph.nodes.containsKey(to)) {
         graph.nodes.put(to, new Node(to));
      }
      Node fromNode = graph.nodes.get(from);//把from的点拿出来
      Node toNode = graph.nodes.get(to);//把to的点拿出来
       
      Edge newEdge = new Edge(weight, fromNode, toNode);//建好一条新的边
      fromNode.nexts.add(toNode);//from出发的点的直接邻居应该包含to的点，把to加入
      fromNode.out++;//出度+1
      toNode.in++;
      fromNode.edges.add(newEdge);//加入from的边集
      graph.edges.add(newEdge);//加入整个图的边集
   }
   return graph;
}
```

- 图的宽度优先遍历：加一个set；**防止重复遍历**

  利用队列实现。从源节点开始按照宽度进队列，然后弹出。每进入一个到队列时，添加到set里，每弹出一个元素时，访问弹出元素直接邻居的时候，若没有才能令其放入队列，直到队列变空

```java
// 从node出发，进行宽度优先遍历
public static void bfs(Node start) {
   if (start == null) {
      return;
   }
   Queue<Node> queue = new LinkedList<>();
   HashSet<Node> set = new HashSet<>();
   queue.add(start);
   set.add(start);
   while (!queue.isEmpty()) {
      Node cur = queue.poll();
      System.out.println(cur.value);
      for (Node next : cur.nexts) {
         if (!set.contains(next)) {
            set.add(next);
            queue.add(next);
         }
      }
   }
}
```

- 图的深度优先遍历：

  利用栈实现。从源节点开始把节点按照深度放入栈，然后弹出

  每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈

  直到栈变空。

```java
public static void dfs(Node node) {
   if (node == null) {
      return;
   }
   Stack<Node> stack = new Stack<>();
   HashSet<Node> set = new HashSet<>();
   stack.add(node);
   set.add(node);
   System.out.println(node.value);
   while (!stack.isEmpty()) {
      Node cur = stack.pop();
      for (Node next : cur.nexts) {
         if (!set.contains(next)) {
            stack.push(cur);
            stack.push(next);
            set.add(next);
            System.out.println(next.value);
            break;
         }
      }
   }
}
```

- 图的拓扑排序算法

  （1）在图中找到所有入度为0的点输出

  （2）把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始

  （3）图的所有点都被删除后，依次输出的顺序就是拓扑顺序

  要求：有向图且其中没有环。

  应用：事件安排、编译顺序

  拓扑序：根据先后顺序能够顺利把工作做完且不缺依赖的顺序

  方法：入度为0的点就是拓扑排序最前面的。然后把这些点的影响撤销掉，再找之后入度为0的点，以此类推。
  
  ```java
  public static List<Node> sortedTopology(Graph graph) {//返回拓扑排序的列表
     // key 某个节点   value 剩余的入度
     HashMap<Node, Integer> inMap = new HashMap<>();
     // 只有剩余入度为0的点，才进入这个队列
     Queue<Node> zeroInQueue = new LinkedList<>();
     for (Node node : graph.nodes.values()) {
        inMap.put(node, node.in);//开始剩余入度就是其原本的入值
        if (node.in == 0) {
           zeroInQueue.add(node);//某个点入度为零，则进队列
        }
     }
     List<Node> result = new ArrayList<>();
     while (!zeroInQueue.isEmpty()) {//入度为零的点不为空
        Node cur = zeroInQueue.poll();//弹出入度为0的点
        result.add(cur);//入读为0点进要返回的队列
        for (Node next : cur.nexts) {
           inMap.put(next, inMap.get(next) - 1);//此点剩余的邻居点剩余入度均-1
           if (inMap.get(next) == 0) {
              zeroInQueue.add(next);
           }
        }
     }
     return result;
  }
  ```

- 附加题：不给你边的信息，只给你点的信息。→根据点次排序，点次高的点在前面

  ```java
  public static class Record {
     public DirectedGraphNode node;
     public long nodes;
  
     public Record(DirectedGraphNode n, long o) {
        node = n;
        nodes = o;
     }
  }
  
  public static class MyComparator implements Comparator<Record> {
  
     @Override
     public int compare(Record o1, Record o2) {
        return o1.nodes == o2.nodes ? 0 : (o1.nodes > o2.nodes ? -1 : 1);
     }
  }
  
  public static ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
     HashMap<DirectedGraphNode, Record> order = new HashMap<>();
     for (DirectedGraphNode cur : graph) {
        f(cur, order);
     }
     ArrayList<Record> recordArr = new ArrayList<>();
     for (Record r : order.values()) {
        recordArr.add(r);
     }
     recordArr.sort(new MyComparator());//根据点次高的排序
     ArrayList<DirectedGraphNode> ans = new ArrayList<DirectedGraphNode>();
     for (Record r : recordArr) {
        ans.add(r.node);
     }
     return ans;
  }
  
  // 当前来到cur点，请返回cur点所到之处，所有的点次！
  // 返回（cur，点次）
  // 缓存！！！！！order   
  //  key : 某一个点的点次，之前算过了！
  //  value : 点次是多少
  public static Record f(DirectedGraphNode cur, HashMap<DirectedGraphNode, Record> order) {
     if (order.containsKey(cur)) {
        return order.get(cur);
     }
     // cur的点次之前没算过！
     long nodes = 0;
     for (DirectedGraphNode next : cur.neighbors) {
        nodes += f(next, order).nodes;//所有邻居把自己返回值的点次告诉我
     }
     Record ans = new Record(cur, nodes + 1);//点次要算上自己
     order.put(cur, ans);
     return ans;
  }
  ```

-  最小生成树算法之Kruskal（在不影响所有点连通的情况下，所有边的权值和最小是多少）

  （1）总是从权值最小的边开始考虑，依次考察权值依次变大的边

  （2）当前的边要么进入最小生成树的集合，要么丢弃

  （3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边

  （4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边

  （5）考察完所有边之后，最小生成树的集合也得到了

  ```java
  public static class EdgeComparator implements Comparator<Edge> {
  	@Override
  	public int compare(Edge o1, Edge o2) {
  		return o1.weight - o2.weight;
  	}
  }
  public static Set<Edge> kruskalMST(Graph graph) {
     UnionFind unionFind = new UnionFind();
     unionFind.makeSets(graph.nodes.values());
     // 从小的边到大的边，依次弹出，小根堆！
     PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());//边的权重谁小谁在上面
     for (Edge edge : graph.edges) { // M 条边
        priorityQueue.add(edge);  // O(logM)
     }
     Set<Edge> result = new HashSet<>();
     while (!priorityQueue.isEmpty()) { // M 条边
        Edge edge = priorityQueue.poll(); // O(logM)
        if (!unionFind.isSameSet(edge.from, edge.to)) { // O(1)
           result.add(edge);//from和to不是一个集合就要这条边
           unionFind.union(edge.from, edge.to);
        }
     }
     return result;
  }
  ```

- 最小生成树法之Prim（无向图）

  （1）可以从任意节点出发来寻找最小生成树

  （2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边

  （3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环

  （4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复（3）

  （5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复（2）

  （6）当所有点都被选取，最小生成树就得到了

```java
public static Set<Edge> primMST(Graph graph) {
   // 解锁的边进入小根堆
   PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());

   // 哪些点被解锁出来了
   HashSet<Node> nodeSet = new HashSet<>();
   
   Set<Edge> result = new HashSet<>(); // 依次挑选的的边在result里

   for (Node node : graph.nodes.values()) { // 随便挑了一个点
      // node 是开始点
      if (!nodeSet.contains(node)) {
         nodeSet.add(node);//解锁该点
         for (Edge edge : node.edges) { // 由一个点，解锁所有相连的边
            priorityQueue.add(edge);
         }
         while (!priorityQueue.isEmpty()) {
            Edge edge = priorityQueue.poll(); // 弹出解锁的边中，最小的边
            Node toNode = edge.to; // 可能的一个新的点
            if (!nodeSet.contains(toNode)) { // tonode不在解锁的点里的时候，就是新的点，
               nodeSet.add(toNode);//把tonode加入到点集
               result.add(edge);//要选中的这条边
               for (Edge nextEdge : toNode.edges) {//tonode连接的所有边也解锁出来
                  priorityQueue.add(nextEdge);
               }
            }
         }
      }
      // break;//防止森林。如果确定整个图是一个，要加上break；
   }
   return result;
}
//K算法当边的数量较多时就比较慢
```

- Dijkstra算法

  有向、无负权重、可以有环；给定一个出发点，问：出发点能到达的点的最短距离

  （1）必须指定一个源点

  （2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即源点到自己的最小距离为0，源点到其他所有点的最小距离都为+∞

  （3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步

  （4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了

```java
public static HashMap<Node, Integer> dijkstra1(Node from) {
   HashMap<Node, Integer> distanceMap = new HashMap<>();
   distanceMap.put(from, 0);
   // 打过对号的点
   HashSet<Node> selectedNodes = new HashSet<>();
   Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);//在distancemap中选择有最小距离的点返回，但是要略过已经打过对号的点
   while (minNode != null) {
      //  原始点  ->  minNode(跳转点)   最小距离distance
      int distance = distanceMap.get(minNode);
      for (Edge edge : minNode.edges) {//考虑跳转点有哪些边
         Node toNode = edge.to;//跳转点的每条边去哪
         if (!distanceMap.containsKey(toNode)) {//toNode没在distancemap中出现
            distanceMap.put(toNode, distance + edge.weight);
         } else { // toNode 在了
            distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));//在旧的值和新的值里选最小值
         }
      }
      selectedNodes.add(minNode);//minnode打对号，已经搞完
      minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
   }
   return distanceMap;
}
```

```java
public static Node getMinDistanceAndUnselectedNode(HashMap<Node, Integer> distanceMap, HashSet<Node> touchedNodes) {
   Node minNode = null;
   int minDistance = Integer.MAX_VALUE;
   for (Entry<Node, Integer> entry : distanceMap.entrySet()) {
      Node node = entry.getKey();
      int distance = entry.getValue();
      if (!touchedNodes.contains(node) && distance < minDistance) {
         minNode = node;
         minDistance = distance;
      }
   }
   return minNode;
}
```



### 从暴力递归到动态规划

#### 综述：

举例：斐波那契数列：F(N)=F(N-1)+F(N-2)，

用递归：有很多的重复过程。相当于一颗高度为n的二叉树，F(6)需要F(5)和F(4)，F(5)又需要F4和F3，这样F4就被计算了两次。动态规划就可以在计算出F4之后把他存到一张表里，这样在第二次计算的时候他就可以直接调用了。（可以理解为缓存）

- **eg：一共N个数，从start出发，走到第一个数或第N个数只能向右或向左走，问：走到aim的方法数有多少？**

递归：

```java
// 机器人当前来到的位置是cur，
	// 机器人还有rest步需要去走，
	// 最终的目标是aim，
	// 有哪些位置？1~N
	// 返回：机器人从cur出发，走过rest步之后，最终停在aim的方法数，是多少？
	public static int process1(int cur, int rest, int aim, int N) {  //cur和rest表示每一个状态2
		if (rest == 0) { // 如果已经不需要走了，走完了！，rest表示还能走的步数
			return cur == aim ? 1 : 0;
		}
		// (cur, rest)
		if (cur == 1) { // 停在1只能去2：1 -> 2
			return process1(2, rest - 1, aim, N);//rest-1，表示走了1步
		}
		// (cur, rest)
		if (cur == N) { // N-1 <- N
			return process1(N - 1, rest - 1, aim, N);
		}
		// (cur, rest)
		return process1(cur - 1, rest - 1, aim, N) + process1(cur + 1, rest - 1, aim, N);
	}
```

动态规划优化递归：（从顶向下的动态规划）

设置一个缓存表，在递归的时候记录值到缓存表，缓存表一旦命中那么直接返回，不用重复计算

```java
public static int ways2(int N, int start, int aim, int K) {
		if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
			return -1;
		}
		int[][] dp = new int[N + 1][K + 1];
		for (int i = 0; i <= N; i++) {
			for (int j = 0; j <= K; j++) {
				dp[i][j] = -1;
			}
		}
		// dp就是缓存表
		// dp[cur][rest] == -1 -> process1(cur, rest)之前没算过！
		// dp[cur][rest] != -1 -> process1(cur, rest)之前算过！返回值，dp[cur][rest]
		// N+1 * K+1
		return process2(start, K, aim, N, dp);
	}

	// cur 范: 1 ~ N
	// rest 范：0 ~ K
	public static int process2(int cur, int rest, int aim, int N, int[][] dp) {
		if (dp[cur][rest] != -1) {  //缓存命中！表示之前算过
			return dp[cur][rest];
		}
		// 之前没算过！
		int ans = 0;
		if (rest == 0) {
			ans = cur == aim ? 1 : 0;
		} else if (cur == 1) {
			ans = process2(2, rest - 1, aim, N, dp);
		} else if (cur == N) {
			ans = process2(N - 1, rest - 1, aim, N, dp);
		} else {
			ans = process2(cur - 1, rest - 1, aim, N, dp) + process2(cur + 1, rest - 1, aim, N, dp);
		}
		dp[cur][rest] = ans;   //在返回之前记入缓存
		return ans;

	}
```

纯动态规划：

来到第一行位置（cur = 1），都依赖其左下角的值（cur+1,rest+1)，最下面的一行(cur = N)都依赖其左上角的值（cur-1,rest-1)。其他位置的值都依赖于左下角和左上角的值之和。

```java
	public static int ways3(int N, int start, int aim, int K) {
		if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
			return -1;
		}
		int[][] dp = new int[N + 1][K + 1];
		dp[aim][0] = 1; //表示剩余0步，到达aim方法数为1
		for (int rest = 1; rest <= K; rest++) { //从第一步开始
			dp[1][rest] = dp[2][rest - 1];  //第一行手动赋值
			for (int cur = 2; cur < N; cur++) {
				dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
			}
			dp[N][rest] = dp[N - 1][rest - 1]; //第N行手动赋值
		}
		return dp[start][K];
	}
```

#### 题目1

- 给定一个整型数组arr，代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张纸牌，规定A先拿B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，A和B都绝顶聪明，请返回最后获胜者（获得分数之和较大者）的分数。

暴力递归: 每次计算两步（包括当前步和后手步，后手由对手执行的结果决定）

```java
// 根据规则，返回获胜者的分数
	public static int win1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int first = f1(arr, 0, arr.length - 1); //先手的人
		int second = g1(arr, 0, arr.length - 1); //后手的人
		return Math.max(first, second);
	}

	// arr[L..R]，先手获得的最好分数返回
	public static int f1(int[] arr, int L, int R) {
		if (L == R) {
			return arr[L]; //只剩一张牌了，先手直接拿走
		}
		int p1 = arr[L] + g1(arr, L + 1, R); //拿走最左面的牌，然后后手处理
		int p2 = arr[R] + g1(arr, L, R - 1); //拿走最右面的牌，然后后手处理
		return Math.max(p1, p2); //因为我是先手，所以选最大的
	}

	// // arr[L..R]，后手获得的最好分数返回
	public static int g1(int[] arr, int L, int R) {
		if (L == R) { //我是后手，对方会拿走，我获得0
			return 0;
		}
		int p1 = f1(arr, L + 1, R); // 对手拿走了L位置的数
		int p2 = f1(arr, L, R - 1); // 对手拿走了R位置的数
		return Math.min(p1, p2);//因为对手先手做决定，所以你只能接受较小值，（对手会选择最大值）
	}
```

根据上面的递归关系，f(0,7)→g(1,7),g(0,6)，g(1,7)→f(1,6),f(2,7)，g(0,6)→f(0,5),f(1,6)

缓存法:

```java
	public static int win2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int N = arr.length;
		int[][] fmap = new int[N][N];
		int[][] gmap = new int[N][N];
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				fmap[i][j] = -1;
				gmap[i][j] = -1; //为-1表示还没有计算过
			}
		}
		int first = f2(arr, 0, arr.length - 1, fmap, gmap); //递归时传递两张表
		int second = g2(arr, 0, arr.length - 1, fmap, gmap);
		return Math.max(first, second);
	}

	// arr[L..R]，先手获得的最好分数返回
	public static int f2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) {
		if (fmap[L][R] != -1) {
			return fmap[L][R];
		}
		int ans = 0;
		if (L == R) {
			ans = arr[L];
		} else {
			int p1 = arr[L] + g2(arr, L + 1, R, fmap, gmap);
			int p2 = arr[R] + g2(arr, L, R - 1, fmap, gmap);
			ans = Math.max(p1, p2);
		}
		fmap[L][R] = ans;  //再返回之前把计算值写入
		return ans;
	}

	// // arr[L..R]，后手获得的最好分数返回
	public static int g2(int[] arr, int L, int R, int[][] fmap, int[][] gmap) {
		if (gmap[L][R] != -1) {  //如果缓存命中，那么直接返回
			return gmap[L][R];
		}
		int ans = 0;
		if (L != R) {
			int p1 = f2(arr, L + 1, R, fmap, gmap); // 对手拿走了L位置的数
			int p2 = f2(arr, L, R - 1, fmap, gmap); // 对手拿走了R位置的数
			ans = Math.min(p1, p2);
		}
		gmap[L][R] = ans;
		return ans;
	}

```

顺序依赖的动态规划：

需要建立一张先手表一张后手表，横坐标R，纵坐标L,当处于对角线元素时，即为L=R，先手拿到的值为arr[L],后手的值为0，同时，这两张表对角线左下的部分是永远用不到的（表示R>L）,最终返回两张表的（0，arr.length-1）位置上的数值比较即可。

依赖关系：f表依赖g表对应位置的左面和下面的值；g表依赖f表对应位置的左面和下面的值，

```java
public static int win3(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int N = arr.length;
		int[][] fmap = new int[N][N];
		int[][] gmap = new int[N][N];
		for (int i = 0; i < N; i++) {
			fmap[i][i] = arr[i]; //赋初值
		}
		for (int startCol = 1; startCol < N; startCol++) {
			int L = 0;
			int R = startCol;
			while (R < N) { //让列不越界
				fmap[L][R] = Math.max(arr[L] + gmap[L + 1][R], arr[R] + gmap[L][R - 1]);//把递归行为替换成在表里取值
				gmap[L][R] = Math.min(fmap[L + 1][R], fmap[L][R - 1]);
				L++;
				R++; //沿着对角线顺着往下
			}
		}
		return Math.max(fmap[0][N - 1], gmap[0][N - 1]);
}
```

![image-20220815215405401](/Users/apple/Library/Application Support/typora-user-images/image-20220815215405401.png)

#### 题目二

- Eg：所有的货物重量和价值都有Weight数组和Value数组，那么将一个容量为m的背包在不超重情况下能得到的最大价值是多少？

使用递归尝试：

```java
// 所有的货，重量和价值，都在w和v数组里
	// 为了方便，其中没有负数
	// bag背包容量，不能超过这个载重
	// 返回：不超重的情况下，能够得到的最大价值
	public static int maxValue(int[] w, int[] v, int bag) {
		if (w == null || v == null || w.length != v.length || w.length == 0) {
			return 0;
		}
		// 尝试函数！
		return process(w, v, 0, bag);
	}

	// index 0~N，当前考虑到了index号货物，index..所有的货物可以自由选择
	//做的选择不能超过背包重量
	// rest 负~bag
	public static int process(int[] w, int[] v, int index, int rest) {
		if (rest < 0) {  //背包容量小于0，设置无效解
			return -1;
		}
		if (index == w.length) { //货物没了
			return 0;
		}
    //有货，index位置的货
    //bag 有空间，0
    //不要当前的货
		int p1 = process(w, v, index + 1, rest);
		int p2 = 0;
    //要当前的货，剩余容量减去当前货物重量
		int next = process(w, v, index + 1, rest - w[index]);
		if (next != -1) { //判断后续是否有效，设置p2位当前货物价值＋有效后续价值
			p2 = v[index] + next;
		}
		return Math.max(p1, p2);
	}
```



动态规划：

```java
public static int dp(int[] w, int[] v, int bag) {
		if (w == null || v == null || w.length != v.length || w.length == 0) {
			return 0;
		}
		int N = w.length;
		int[][] dp = new int[N + 1][bag + 1];
		for (int index = N - 1; index >= 0; index--) {
			for (int rest = 0; rest <= bag; rest++) {
				int p1 = dp[index + 1][rest];
				int p2 = 0;
				int next = rest - w[index] < 0 ? -1 : dp[index + 1][rest - w[index]]; //如果是无效解，返回-1，否则从表中拿
				if (next != -1) {
					p2 = v[index] + next;
				}
				dp[index][rest] = Math.max(p1, p2);
			}
		}
		return dp[0][bag];
	}
```

#### 题目三

example2：规定1和A对应，2和B对应，...，26和z对应，那么一个数字字符串就可以转换为aaa，ka，ak，1对应a，11对应k。给定一个只有数字字符串组成的字符串str，返回有多少种解决方法

- 暴力递归：

```java
	// str只含有数字字符0~9
	// 返回多少种转化方案
	public static int number(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}
		return process(str.toCharArray(), 0);
	}	
// str[0..i-1]转化无需过问
	// str[i.....]去转化，返回有多少种转化方法
	public static int process(char[] str, int i) {
		if (i == str.length) {
			return 1;
		} //i到了中止位置，说明找到了一种方法
		// i没到最后，说明有字符
		if (str[i] == '0') { // 之前的决定有问题，因为0不能能、对应一个字母
			return 0;
		}
		// str[i] != '0'
		// 可能性一，i对应的那一个字符单转
		int ways = process(str, i + 1);
        //可能性二：i和i+1位置共同构成一个字符，条件：i+1位置不越界，有字符，并且他们两个对应的数值＜26
		if (i + 1 < str.length && (str[i] - '0') * 10 + str[i + 1] - '0' < 27) {
			ways += process(str, i + 2);
		}
		return ways;
	}
```

- 动态规划

```java
	// 从右往左的动态规划
	// 就是上面方法的动态规划版本
	// dp[i]表示：str[i...]有多少种转化方式
	public static int dp1(String s) {
		if (s == null || s.length() == 0) {
			return 0;
		}
		char[] str = s.toCharArray();
		int N = str.length;
		int[] dp = new int[N + 1];
		dp[N] = 1;
        //任何一个位置都依赖后面位置的
		for (int i = N - 1; i >= 0; i--) {
			if (str[i] != '0') {
                //只有str[i]不为0，dp【i】才有可能变成一个正常的数
				int ways = dp[i + 1];
				if (i + 1 < str.length && (str[i] - '0') * 10 + str[i + 1] - '0' < 27) {
					ways += dp[i + 2];
				}
				dp[i] = ways; //递归的返回变成动态规划的设置
			}
		}
		return dp[0];
	}
```

#### 题目四

给定一个字符串str，给定一个字符串数组arr，出现的字符都是小写英文，arr每一个字符串代表一个贴纸，可以把单个字符剪开使用，目的是拼出str，返回需要至少多少张贴纸可以完成这个任务。

ba+ba+c 3    abcd+abcd 2    ba abcd 2

eg: str=babac, arr={ba,c,abcd} 至少需要两张贴纸ba和abcd，因为使用这两张贴纸，把每一个字符单独剪开，含有2个a2个b一个c，所以返回2



二维数组可以表示所有贴纸 ，所有贴纸的词频都提前统计好

```java
public static int minStickers2(String[] stickers, String target) {
		int N = stickers.length;
		// 关键优化(用词频表替代贴纸数组)
		int[][] counts = new int[N][26];//一共N个贴纸，每个贴纸a~z
		for (int i = 0; i < N; i++) { //生成词频统计表
			char[] str = stickers[i].toCharArray();
			for (char cha : str) {
				counts[i][cha - 'a']++;
			}
		}
		int ans = process2(counts, target);
		return ans == Integer.MAX_VALUE ? -1 : ans;
	}	
// stickers[i] 数组，当初i号贴纸的字符统计 int[][] stickers -> 所有的贴纸
	// 每一种贴纸都有无穷张
	// 返回搞定target的最少张数
	// 最少张数
public static int process2(int[][] stickers, String t) {
		if (t.length() == 0) {
			return 0;
		}
		// target做出词频统计
		// target  aabbc  2 2 1..
		//           下标  0 1 2..
		char[] target = t.toCharArray();
		int[] tcounts = new int[26];
		for (char cha : target) {
			tcounts[cha - 'a']++;
		}
		int N = stickers.length;
		int min = Integer.MAX_VALUE;
		for (int i = 0; i < N; i++) {
			// 尝试第一张贴纸是谁
			int[] sticker = stickers[i];
			// 最关键的优化(重要的剪枝!这一步也是贪心!)
			if (sticker[target[0] - 'a'] > 0) {//只含有第一个字符的贴纸先试！
				StringBuilder builder = new StringBuilder();
				for (int j = 0; j < 26; j++) {
					if (tcounts[j] > 0) {
						int nums = tcounts[j] - sticker[j];
						for (int k = 0; k < nums; k++) {
							builder.append((char) (j + 'a'));
						}
					}
				}
				String rest = builder.toString();
				min = Math.min(min, process2(stickers, rest));
			}
		}
		return min + (min == Integer.MAX_VALUE ? 0 : 1);
	}
```



#### 题目五：

eg：最长公共子序列

```java
public static int longestCommonSubsequence1(String s1, String s2) {
		if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
			return 0;
		}
		char[] str1 = s1.toCharArray();
		char[] str2 = s2.toCharArray();
		// 尝试
		return process1(str1, str2, str1.length - 1, str2.length - 1);
	}
	
//str1[0, i]  与 str2[0, j] 最长公共子序列多长？
	public static int process1(char[] str1, char[] str2, int i, int j) {
		if (i == 0 && j == 0) {  //str1和str2只有第一个字符比较，最多的公共子序列为1
			return str1[i] == str2[j] ? 1 : 0;
		} else if (i == 0) {   //j不等于0
			if (str1[i] == str2[j]) {
				return 1;
			} else {
				return process1(str1, str2, i, j - 1);
			}
		} else if (j == 0) {//i不等于0
			if (str1[i] == str2[j]) {
				return 1;
			} else {
				return process1(str1, str2, i - 1, j);
			}
		} else { // i != 0 && j != 0
            //公共子序列可能既不以i结尾，也不以j结尾，可能以j结尾，可能以i结尾
			int p1 = process1(str1, str2, i - 1, j);
			int p2 = process1(str1, str2, i, j - 1);
			int p3 = str1[i] == str2[j] ? (1 + process1(str1, str2, i - 1, j - 1)) : 0;//如果不相等，那么设置一个无效解
			return Math.max(p1, Math.max(p2, p3));
		}
	}
```

动态规划：

```java
public static int longestCommonSubsequence2(String s1, String s2) {
		if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
			return 0;
		}
		char[] str1 = s1.toCharArray();
		char[] str2 = s2.toCharArray();
		int N = str1.length;
		int M = str2.length;
		int[][] dp = new int[N][M];
		dp[0][0] = str1[0] == str2[0] ? 1 : 0; //初始化
		for (int j = 1; j < M; j++) {
			dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1]; //第0行赋值
		}
		for (int i = 1; i < N; i++) {
			dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0]; //第0列赋值
		}
		for (int i = 1; i < N; i++) {
			for (int j = 1; j < M; j++) {
				int p1 = dp[i - 1][j];
				int p2 = dp[i][j - 1];
				int p3 = str1[i] == str2[j] ? (1 + dp[i - 1][j - 1]) : 0;
				dp[i][j] = Math.max(p1, Math.max(p2, p3));
			}
		}
		return dp[N - 1][M - 1];
	}
```

